import SwiftUI
import AVFoundation
import Photos
import Combine
import UIKit
import CoreImage
import CoreImage.CIFilterBuiltins

// MARK: - CUSTOM FONT SYSTEM
// Typography using Inter for headings, Geist for body/subheadings
struct AppFonts {
    // Inter - Headings (requires Inter font to be added to app bundle)
    static func interBold(_ size: CGFloat) -> Font {
        .custom("Inter-Bold", size: size, relativeTo: .headline)
    }

    static func interSemiBold(_ size: CGFloat) -> Font {
        .custom("Inter-SemiBold", size: size, relativeTo: .headline)
    }

    static func interMedium(_ size: CGFloat) -> Font {
        .custom("Inter-Medium", size: size, relativeTo: .headline)
    }

    static func interRegular(_ size: CGFloat) -> Font {
        .custom("Inter-Regular", size: size, relativeTo: .body)
    }

    // Geist - Body/Subheadings (requires Geist font to be added to app bundle)
    static func geistBold(_ size: CGFloat) -> Font {
        .custom("Geist-Bold", size: size, relativeTo: .body)
    }

    static func geistSemiBold(_ size: CGFloat) -> Font {
        .custom("Geist-SemiBold", size: size, relativeTo: .body)
    }

    static func geistMedium(_ size: CGFloat) -> Font {
        .custom("Geist-Medium", size: size, relativeTo: .body)
    }

    static func geistRegular(_ size: CGFloat) -> Font {
        .custom("Geist-Regular", size: size, relativeTo: .body)
    }

    // Semantic typography styles
    static var largeTitle: Font { interBold(34) }
    static var title: Font { interBold(28) }
    static var title2: Font { interSemiBold(22) }
    static var title3: Font { interSemiBold(20) }
    static var headline: Font { interSemiBold(17) }
    static var subheadline: Font { geistMedium(15) }
    static var body: Font { geistRegular(17) }
    static var callout: Font { geistRegular(16) }
    static var footnote: Font { geistRegular(13) }
    static var caption: Font { geistMedium(12) }
    static var caption2: Font { geistRegular(11) }
}

// MARK: - CUSTOM UI COMPONENTS
// Custom color scheme
struct AppColors {
    static let primary = Color.blue
    static let secondary = Color.gray
    static let accent = Color.blue
    static let background = Color.black
    static let surface = Color(white: 0.12)
    static let surfaceElevated = Color(white: 0.18)
    static let textPrimary = Color.white
    static let textSecondary = Color.gray
    static let success = Color.green
    static let warning = Color.orange
    static let error = Color.red
}

// Custom button styles
struct CustomPrimaryButtonStyle: ButtonStyle {
    var backgroundColor: Color = AppColors.primary
    var foregroundColor: Color = AppColors.textPrimary

    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(AppFonts.headline)
            .foregroundColor(foregroundColor)
            .padding(.horizontal, 24)
            .padding(.vertical, 12)
            .background(backgroundColor.opacity(configuration.isPressed ? 0.8 : 1.0))
            .cornerRadius(12)
            .scaleEffect(configuration.isPressed ? 0.98 : 1.0)
            .animation(.easeInOut(duration: 0.15), value: configuration.isPressed)
    }
}

struct CustomSecondaryButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(AppFonts.subheadline)
            .foregroundColor(AppColors.textPrimary)
            .padding(.horizontal, 20)
            .padding(.vertical, 10)
            .background(AppColors.surface.opacity(configuration.isPressed ? 0.6 : 0.8))
            .cornerRadius(10)
            .overlay(
                RoundedRectangle(cornerRadius: 10)
                    .stroke(AppColors.secondary.opacity(0.3), lineWidth: 1)
            )
            .scaleEffect(configuration.isPressed ? 0.98 : 1.0)
            .animation(.easeInOut(duration: 0.15), value: configuration.isPressed)
    }
}

struct CustomIconButtonStyle: ButtonStyle {
    var size: CGFloat = 44
    var backgroundColor: Color = AppColors.surface

    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .frame(width: size, height: size)
            .background(backgroundColor.opacity(configuration.isPressed ? 0.6 : 0.8))
            .cornerRadius(size / 2)
            .scaleEffect(configuration.isPressed ? 0.92 : 1.0)
            .animation(.easeInOut(duration: 0.15), value: configuration.isPressed)
    }
}

// MARK: - CUSTOM BOTTOM NAVIGATION BAR
struct CustomBottomNavBar: View {
    @Binding var selectedTab: Int

    var body: some View {
        HStack(spacing: 0) {
            NavBarItem(
                icon: "camera.fill",
                label: "Camera",
                isSelected: selectedTab == 0,
                action: { selectedTab = 0 }
            )

            NavBarItem(
                icon: "folder.fill",
                label: "Portfolios",
                isSelected: selectedTab == 1,
                action: { selectedTab = 1 }
            )

            NavBarItem(
                icon: "photo.on.rectangle",
                label: "Gallery",
                isSelected: selectedTab == 2,
                action: { selectedTab = 2 }
            )
        }
        .padding(.horizontal, 20)
        .padding(.top, 18) // 18pt padding between nav bar top edge and highlight area
        .padding(.bottom, 0) // Minimal bottom padding - safe area handled by background extension
        .background(
            AppColors.surface
                .overlay(
                    Rectangle()
                        .fill(AppColors.secondary.opacity(0.2))
                        .frame(height: 1),
                    alignment: .top
                )
                .ignoresSafeArea(.all, edges: .bottom)
        )
    }
}

struct NavBarItem: View {
    let icon: String
    let label: String
    let isSelected: Bool
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            VStack(spacing: 2) {
                Image(systemName: icon)
                    .font(.system(size: 20, weight: isSelected ? .semibold : .regular))
                    .foregroundColor(isSelected ? AppColors.primary : AppColors.textSecondary)

                Text(label)
                    .font(AppFonts.caption2)
                    .foregroundColor(isSelected ? AppColors.primary : AppColors.textSecondary)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 2)
            .background(
                isSelected ?
                    AppColors.primary.opacity(0.1)
                        .cornerRadius(10)
                    : Color.clear.cornerRadius(10)
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

// MARK: - CAMERA LOADING VIEW
struct CameraLoadingView: View {
    @State private var progress: CGFloat = 0

    var body: some View {
        ZStack {
            AppColors.background
                .ignoresSafeArea()

            VStack(spacing: 24) {
                Text("Launching camera")
                    .font(AppFonts.headline)
                    .foregroundColor(AppColors.textPrimary)

                // Pill-shaped progress bar
                ZStack(alignment: .leading) {
                    Capsule()
                        .fill(AppColors.surface)
                        .frame(width: 200, height: 8)

                    Capsule()
                        .fill(AppColors.primary)
                        .frame(width: 200 * progress, height: 8)
                }
            }
        }
        .onAppear {
            // Animate progress bar
            withAnimation(.easeInOut(duration: 1.5)) {
                progress = 1.0
            }
        }
    }
}

// MARK: - MAIN ENTRY POINT
struct ContentView: View {
    @State private var selectedTab = 0 // Track tab selection
    @StateObject private var sharedCameraService = CameraService()
    @State private var showCameraLoading = false
    @State private var cameraHasLoaded = false

    var body: some View {
        ZStack(alignment: .bottom) {
            // Keep all views in ZStack, use opacity for instant switching
            // This prevents recreating views and losing state

            // Camera view - always exists to maintain session
            DentalCameraSetupView(selectedTab: $selectedTab, cameraService: sharedCameraService)
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .opacity(selectedTab == 0 && !showCameraLoading ? 1 : 0)
                .zIndex(selectedTab == 0 ? 1 : 0)
                .animation(.easeInOut(duration: 0.2), value: selectedTab)

            // Portfolios view
            PortfoliosView()
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .opacity(selectedTab == 1 ? 1 : 0)
                .zIndex(selectedTab == 1 ? 1 : 0)
                .animation(.easeInOut(duration: 0.2), value: selectedTab)

            // Gallery view
            GalleryView()
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .opacity(selectedTab == 2 ? 1 : 0)
                .zIndex(selectedTab == 2 ? 1 : 0)
                .animation(.easeInOut(duration: 0.2), value: selectedTab)

            // Camera loading view
            if showCameraLoading {
                CameraLoadingView()
                    .zIndex(2)
            }

            // Custom bottom navigation - always visible, instant highlight
            CustomBottomNavBar(selectedTab: $selectedTab)
                .zIndex(3)
        }
        .preferredColorScheme(.dark)
        .ignoresSafeArea(.keyboard)
        .onAppear {
            PhotoLibraryManager.shared.createAlbumIfNeeded()
        }
        .onChange(of: selectedTab) { newTab in
            // Show loading only when switching TO camera and it hasn't loaded yet
            if newTab == 0 && !cameraHasLoaded && !sharedCameraService.isSessionReady {
                showCameraLoading = true
            }
        }
        .onChange(of: sharedCameraService.isSessionReady) { ready in
            if ready {
                cameraHasLoaded = true
                // Small delay to let progress bar complete visually
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                    showCameraLoading = false
                }
            }
        }
    }
}

// MARK: - PHOTO METADATA MODEL
struct ToothEntry: Codable, Hashable, Identifiable {
    var id: String { "\(procedure)-\(toothNumber)-\(dateString)" }
    let procedure: String
    let toothNumber: Int
    let date: Date

    var dateString: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        return formatter.string(from: date)
    }

    var displayString: String {
        "Tooth \(toothNumber) - \(dateString)"
    }
}

struct PhotoMetadata: Codable {
    var procedure: String?
    var toothNumber: Int?
    var toothDate: Date?
    var stage: String?  // "Preparation" or "Restoration"
    var angle: String?  // "Occlusal", "Buccal/Facial", etc.
    var rating: Int?    // 1-5 stars

    var toothEntry: ToothEntry? {
        guard let proc = procedure, let num = toothNumber, let date = toothDate else { return nil }
        return ToothEntry(procedure: proc, toothNumber: num, date: date)
    }

    var isComplete: Bool {
        procedure != nil && toothNumber != nil && toothDate != nil && stage != nil && angle != nil
    }

    var summaryText: String {
        var parts: [String] = []
        if let p = procedure { parts.append(p) }
        if let t = toothNumber { parts.append("#\(t)") }
        if let s = stage { parts.append(s.prefix(4).description) }
        if let a = angle { parts.append(a) }
        return parts.isEmpty ? "Choose procedure" : parts.joined(separator: " · ")
    }
}

// MARK: - PORTFOLIO MODELS
struct PortfolioRequirement: Codable, Identifiable, Hashable {
    let id: String
    var procedure: String           // e.g., "Class 1", "Crown"
    var stages: [String]            // e.g., ["Preparation", "Restoration"]
    var angles: [String]            // e.g., ["Occlusal", "Buccal/Facial"]
    var angleCounts: [String: Int]  // Per-angle photo counts, e.g., ["Occlusal": 2, "Buccal/Facial": 1]

    init(id: String = UUID().uuidString, procedure: String, stages: [String], angles: [String], angleCounts: [String: Int] = [:]) {
        self.id = id
        self.procedure = procedure
        self.stages = stages
        self.angles = angles
        // Default to 1 for any angle without a specified count
        var counts = angleCounts
        for angle in angles {
            if counts[angle] == nil {
                counts[angle] = 1
            }
        }
        self.angleCounts = counts
    }

    // Total number of photos required for this requirement
    var totalRequired: Int {
        var total = 0
        for angle in angles {
            let count = angleCounts[angle] ?? 1
            total += stages.count * count
        }
        return total
    }

    // Display string for the requirement
    var displayString: String {
        let stageText = stages.count == 2 ? "Both Stages" : stages.joined(separator: ", ")
        let angleText = angles.count == 7 ? "All Angles" : angles.joined(separator: ", ")
        return "\(procedure) · \(stageText) · \(angleText)"
    }
}

struct Portfolio: Codable, Identifiable, Hashable {
    let id: String
    var name: String
    var createdDate: Date
    var requirements: [PortfolioRequirement]
    var notes: String?

    init(id: String = UUID().uuidString, name: String, createdDate: Date = Date(), requirements: [PortfolioRequirement] = [], notes: String? = nil) {
        self.id = id
        self.name = name
        self.createdDate = createdDate
        self.requirements = requirements
        self.notes = notes
    }

    var dateString: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter.string(from: createdDate)
    }
}

// MARK: - GALLERY NAVIGATION STATE
class GalleryNavigationState: ObservableObject {
    static let shared = GalleryNavigationState()

    @Published var pendingProcedure: String? = nil
    @Published var pendingToothNumber: Int? = nil
    @Published var pendingToothDate: Date? = nil
    @Published var pendingHighlightPhotoId: String? = nil
    @Published var navigatedFromCamera: Bool = false

    func setNavigation(procedure: String?, toothNumber: Int?, toothDate: Date?, photoId: String?) {
        pendingProcedure = procedure
        pendingToothNumber = toothNumber
        pendingToothDate = toothDate
        pendingHighlightPhotoId = photoId
        navigatedFromCamera = true
    }

    func clearNavigation() {
        pendingProcedure = nil
        pendingToothNumber = nil
        pendingToothDate = nil
        pendingHighlightPhotoId = nil
        navigatedFromCamera = false
    }
}

// MARK: - METADATA MANAGER (PERSISTENCE)
class MetadataManager: ObservableObject {
    static let shared = MetadataManager()

    // Special folder for unsorted photos
    static let unsortedPhotosFolder = "Unsorted Photos"

    // Procedure options (can add, cannot delete base ones or Unsorted Photos)
    @Published var procedures: [String] = ["Unsorted Photos", "Class 1", "Class 2", "Class 3", "Crown"]
    private let baseProcedures = ["Unsorted Photos", "Class 1", "Class 2", "Class 3", "Crown"]

    // Stage options (fixed)
    let stages: [String] = ["Preparation", "Restoration"]

    // Angle options (fixed)
    let angles: [String] = ["Occlusal", "Buccal/Facial", "Lingual", "Proximal", "Mesial", "Distal", "Other"]

    // Tooth entries history per procedure
    @Published var toothHistory: [String: [ToothEntry]] = [:]  // procedure -> [ToothEntry]

    // Asset metadata map
    @Published var assetMetadata: [String: PhotoMetadata] = [:]  // assetID -> PhotoMetadata

    // Folder colors (procedure -> hex color string)
    @Published var folderColors: [String: String] = [:]

    // Portfolios
    @Published var portfolios: [Portfolio] = []

    // UserDefaults keys
    private let proceduresKey = "DentalPortfolio_Procedures_v2"
    private let toothHistoryKey = "DentalPortfolio_ToothHistory"
    private let assetMetadataKey = "DentalPortfolio_AssetMetadata"
    private let folderColorsKey = "DentalPortfolio_FolderColors"
    private let portfoliosKey = "DentalPortfolio_Portfolios_v1"

    // Default folder colors
    private let defaultColors: [String: String] = [
        "Unsorted Photos": "808080",  // Gray
        "Class 1": "007AFF",          // Blue
        "Class 2": "34C759",          // Green
        "Class 3": "FF9500",          // Orange
        "Crown": "AF52DE"             // Purple
    ]

    init() {
        loadData()
    }

    func addProcedure(_ procedure: String) {
        guard !procedure.isEmpty && !procedures.contains(procedure) else { return }
        procedures.append(procedure)
        saveProcedures()
    }

    func canDeleteProcedure(_ procedure: String) -> Bool {
        return !baseProcedures.contains(procedure)
    }

    func canRenameProcedure(_ procedure: String) -> Bool {
        return !baseProcedures.contains(procedure)
    }

    func deleteProcedure(_ procedure: String) {
        guard canDeleteProcedure(procedure) else { return }
        procedures.removeAll { $0 == procedure }
        folderColors.removeValue(forKey: procedure)
        saveProcedures()
        saveFolderColors()
    }

    // Move all photos from one procedure to "Unsorted Photos"
    func movePhotosToUnsorted(from procedure: String) {
        for (assetID, var metadata) in assetMetadata {
            if metadata.procedure == procedure {
                metadata.procedure = MetadataManager.unsortedPhotosFolder
                assetMetadata[assetID] = metadata
            }
        }
        // Remove tooth history for this procedure
        toothHistory.removeValue(forKey: procedure)
        saveAssetMetadata()
        saveToothHistory()
    }

    // Rename a procedure
    func renameProcedure(_ oldName: String, to newName: String) {
        guard canRenameProcedure(oldName), !newName.isEmpty, !procedures.contains(newName) else { return }

        // Update procedures list
        if let index = procedures.firstIndex(of: oldName) {
            procedures[index] = newName
        }

        // Update all asset metadata
        for (assetID, var metadata) in assetMetadata {
            if metadata.procedure == oldName {
                metadata.procedure = newName
                assetMetadata[assetID] = metadata
            }
        }

        // Update tooth history
        if let entries = toothHistory[oldName] {
            toothHistory[newName] = entries.map { entry in
                ToothEntry(procedure: newName, toothNumber: entry.toothNumber, date: entry.date)
            }
            toothHistory.removeValue(forKey: oldName)
        }

        // Update folder color
        if let color = folderColors[oldName] {
            folderColors[newName] = color
            folderColors.removeValue(forKey: oldName)
        }

        saveProcedures()
        saveAssetMetadata()
        saveToothHistory()
        saveFolderColors()
    }

    // Get photo count for a procedure
    func photoCount(for procedure: String) -> Int {
        return assetMetadata.values.filter { $0.procedure == procedure }.count
    }

    // Folder color methods
    func getFolderColor(for procedure: String) -> Color {
        let hexString = folderColors[procedure] ?? defaultColors[procedure] ?? "007AFF"
        return Color(hex: hexString) ?? .blue
    }

    func setFolderColor(_ color: Color, for procedure: String) {
        folderColors[procedure] = color.toHex() ?? "007AFF"
        saveFolderColors()
    }

    private func saveFolderColors() {
        if let encoded = try? JSONEncoder().encode(folderColors) {
            UserDefaults.standard.set(encoded, forKey: folderColorsKey)
        }
    }

    func addToothEntry(_ entry: ToothEntry) {
        var entries = toothHistory[entry.procedure] ?? []
        // Check if this exact tooth/date combo already exists
        if !entries.contains(where: { $0.toothNumber == entry.toothNumber && Calendar.current.isDate($0.date, inSameDayAs: entry.date) }) {
            entries.append(entry)
            toothHistory[entry.procedure] = entries
            saveToothHistory()
        }
    }

    func getToothEntries(for procedure: String) -> [ToothEntry] {
        return toothHistory[procedure] ?? []
    }

    func assignMetadata(_ metadata: PhotoMetadata, to assetID: String) {
        assetMetadata[assetID] = metadata

        // Also add to tooth history if applicable
        if let entry = metadata.toothEntry {
            addToothEntry(entry)
        }

        saveAssetMetadata()
    }

    func getMetadata(for assetID: String) -> PhotoMetadata? {
        return assetMetadata[assetID]
    }

    func setRating(_ rating: Int, for assetID: String) {
        var metadata = assetMetadata[assetID] ?? PhotoMetadata()
        metadata.rating = max(1, min(5, rating))
        assetMetadata[assetID] = metadata
        saveAssetMetadata()
    }

    func getRating(for assetID: String) -> Int? {
        return assetMetadata[assetID]?.rating
    }

    // MARK: - Portfolio Management
    func addPortfolio(_ portfolio: Portfolio) {
        portfolios.append(portfolio)
        savePortfolios()
    }

    func updatePortfolio(_ portfolio: Portfolio) {
        if let index = portfolios.firstIndex(where: { $0.id == portfolio.id }) {
            portfolios[index] = portfolio
            savePortfolios()
        }
    }

    func deletePortfolio(_ portfolio: Portfolio) {
        portfolios.removeAll { $0.id == portfolio.id }
        savePortfolios()
    }

    func getPortfolio(by id: String) -> Portfolio? {
        return portfolios.first { $0.id == id }
    }

    // Add a requirement to a portfolio
    func addRequirement(to portfolioId: String, requirement: PortfolioRequirement) {
        if let index = portfolios.firstIndex(where: { $0.id == portfolioId }) {
            portfolios[index].requirements.append(requirement)
            savePortfolios()
        }
    }

    // Remove a requirement from a portfolio
    func removeRequirement(from portfolioId: String, requirementId: String) {
        if let index = portfolios.firstIndex(where: { $0.id == portfolioId }) {
            portfolios[index].requirements.removeAll { $0.id == requirementId }
            savePortfolios()
        }
    }

    // Get count of photos matching a specific requirement criteria
    func getPhotoCount(for requirement: PortfolioRequirement, stage: String, angle: String) -> Int {
        return assetMetadata.values.filter { metadata in
            metadata.procedure == requirement.procedure &&
            metadata.stage == stage &&
            metadata.angle == angle
        }.count
    }

    // Get asset IDs matching specific criteria
    func getMatchingAssetIDs(procedure: String, stage: String, angle: String) -> [String] {
        return assetMetadata.filter { (_, metadata) in
            metadata.procedure == procedure &&
            metadata.stage == stage &&
            metadata.angle == angle
        }.map { $0.key }
    }

    // Update a requirement in a portfolio
    func updateRequirement(in portfolioId: String, requirement: PortfolioRequirement) {
        if let index = portfolios.firstIndex(where: { $0.id == portfolioId }) {
            if let reqIndex = portfolios[index].requirements.firstIndex(where: { $0.id == requirement.id }) {
                portfolios[index].requirements[reqIndex] = requirement
                savePortfolios()
            }
        }
    }

    // Get total fulfilled count for a requirement
    func getFulfilledCount(for requirement: PortfolioRequirement) -> Int {
        var count = 0
        for stage in requirement.stages {
            for angle in requirement.angles {
                let photoCount = getPhotoCount(for: requirement, stage: stage, angle: angle)
                let needed = requirement.angleCounts[angle] ?? 1
                count += min(photoCount, needed)
            }
        }
        return count
    }

    // Check if a requirement is fully fulfilled
    func isRequirementFulfilled(_ requirement: PortfolioRequirement) -> Bool {
        for stage in requirement.stages {
            for angle in requirement.angles {
                let photoCount = getPhotoCount(for: requirement, stage: stage, angle: angle)
                let needed = requirement.angleCounts[angle] ?? 1
                if photoCount < needed {
                    return false
                }
            }
        }
        return true
    }

    // Get portfolio completion stats
    func getPortfolioStats(_ portfolio: Portfolio) -> (fulfilled: Int, total: Int) {
        var fulfilled = 0
        var total = 0
        for req in portfolio.requirements {
            total += req.totalRequired
            fulfilled += getFulfilledCount(for: req)
        }
        return (fulfilled, total)
    }

    // Get percentage completion for a portfolio
    func getPortfolioCompletionPercentage(_ portfolio: Portfolio) -> Double {
        let stats = getPortfolioStats(portfolio)
        guard stats.total > 0 else { return 0 }
        return Double(stats.fulfilled) / Double(stats.total) * 100
    }

    private func savePortfolios() {
        if let encoded = try? JSONEncoder().encode(portfolios) {
            UserDefaults.standard.set(encoded, forKey: portfoliosKey)
        }
    }

    // MARK: - Persistence
    private func saveProcedures() {
        UserDefaults.standard.set(procedures, forKey: proceduresKey)
    }

    private func saveToothHistory() {
        if let encoded = try? JSONEncoder().encode(toothHistory) {
            UserDefaults.standard.set(encoded, forKey: toothHistoryKey)
        }
    }

    private func saveAssetMetadata() {
        if let encoded = try? JSONEncoder().encode(assetMetadata) {
            UserDefaults.standard.set(encoded, forKey: assetMetadataKey)
        }
    }

    private func loadData() {
        // Load procedures
        if let procs = UserDefaults.standard.stringArray(forKey: proceduresKey) {
            // Merge with base procedures to ensure they exist
            var merged = baseProcedures
            for p in procs where !merged.contains(p) {
                merged.append(p)
            }
            procedures = merged
        }

        // Load tooth history
        if let data = UserDefaults.standard.data(forKey: toothHistoryKey),
           let decoded = try? JSONDecoder().decode([String: [ToothEntry]].self, from: data) {
            toothHistory = decoded
        }

        // Load asset metadata
        if let data = UserDefaults.standard.data(forKey: assetMetadataKey),
           let decoded = try? JSONDecoder().decode([String: PhotoMetadata].self, from: data) {
            assetMetadata = decoded
        }

        // Load folder colors
        if let data = UserDefaults.standard.data(forKey: folderColorsKey),
           let decoded = try? JSONDecoder().decode([String: String].self, from: data) {
            folderColors = decoded
        }

        // Load portfolios
        if let data = UserDefaults.standard.data(forKey: portfoliosKey),
           let decoded = try? JSONDecoder().decode([Portfolio].self, from: data) {
            portfolios = decoded
        }
    }
}

// MARK: - Color Extensions for Hex Conversion
extension Color {
    init?(hex: String) {
        var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
        hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")

        var rgb: UInt64 = 0
        guard Scanner(string: hexSanitized).scanHexInt64(&rgb) else { return nil }

        let r = Double((rgb & 0xFF0000) >> 16) / 255.0
        let g = Double((rgb & 0x00FF00) >> 8) / 255.0
        let b = Double(rgb & 0x0000FF) / 255.0

        self.init(red: r, green: g, blue: b)
    }

    func toHex() -> String? {
        guard let components = UIColor(self).cgColor.components, components.count >= 3 else { return nil }
        let r = Int(components[0] * 255)
        let g = Int(components[1] * 255)
        let b = Int(components[2] * 255)
        return String(format: "%02X%02X%02X", r, g, b)
    }
}

// MARK: - Legacy TagManager (kept for backward compatibility)
class TagManager: ObservableObject {
    static let shared = TagManager()

    @Published var procedureTags: [String] = []
    @Published var otherTags: [String] = []
    @Published var assetProcedureMap: [String: String] = [:]
    @Published var assetOtherTagsMap: [String: [String]] = [:]

    private let procedureKey = "DentalPortfolio_Procedures"
    private let otherTagsKey = "DentalPortfolio_OtherTags"
    private let assetProcMapKey = "DentalPortfolio_AssetProcMap"
    private let assetOtherMapKey = "DentalPortfolio_AssetOtherMap"

    init() {
        loadData()
        if procedureTags.isEmpty {
            procedureTags = ["Crown", "Bridge", "Veneer", "Implant", "Denture", "Ortho"]
            saveProcedures()
        }
        if otherTags.isEmpty {
            otherTags = ["Upper", "Lower", "Anterior", "Posterior", "Prep", "Restoration"]
            saveOtherTags()
        }
    }

    func addProcedure(_ tag: String) {
        if !procedureTags.contains(tag) && !tag.isEmpty { procedureTags.append(tag); saveProcedures() }
    }
    func deleteProcedure(_ tag: String) {
        procedureTags.removeAll { $0 == tag }; saveProcedures()
    }
    func addOtherTag(_ tag: String) {
        if !otherTags.contains(tag) && !tag.isEmpty { otherTags.append(tag); saveOtherTags() }
    }
    func deleteOtherTag(_ tag: String) {
        otherTags.removeAll { $0 == tag }; saveOtherTags()
    }
    func assign(procedure: String?, otherTags: [String], to assetID: String) {
        if let proc = procedure { assetProcedureMap[assetID] = proc }
        assetOtherTagsMap[assetID] = otherTags
        saveMaps()
    }
    func getProcedure(for assetID: String) -> String? { return assetProcedureMap[assetID] }
    func getOtherTags(for assetID: String) -> [String] { return assetOtherTagsMap[assetID] ?? [] }

    private func saveProcedures() { UserDefaults.standard.set(procedureTags, forKey: procedureKey) }
    private func saveOtherTags() { UserDefaults.standard.set(otherTags, forKey: otherTagsKey) }
    private func saveMaps() {
        UserDefaults.standard.set(assetProcedureMap, forKey: assetProcMapKey)
        UserDefaults.standard.set(assetOtherTagsMap, forKey: assetOtherMapKey)
    }
    private func loadData() {
        if let p = UserDefaults.standard.stringArray(forKey: procedureKey) { procedureTags = p }
        if let o = UserDefaults.standard.stringArray(forKey: otherTagsKey) { otherTags = o }
        if let pm = UserDefaults.standard.dictionary(forKey: assetProcMapKey) as? [String: String] { assetProcedureMap = pm }
        if let om = UserDefaults.standard.dictionary(forKey: assetOtherMapKey) as? [String: [String]] { assetOtherTagsMap = om }
    }
}

// MARK: - CAMERA SERVICE (AVFoundation)
class CameraService: NSObject, ObservableObject, AVCapturePhotoCaptureDelegate {
    @Published var session = AVCaptureSession()
    @Published var capturedImage: UIImage? = nil
    @Published var isSessionReady = false

    // Exposure & Flash State
    @Published var currentExposure: Float = 0.0
    @Published var minExposure: Float = -2.0
    @Published var maxExposure: Float = 2.0
    @Published var flashMode: AVCaptureDevice.FlashMode = .off

    // Zoom State
    @Published var currentZoom: CGFloat = 1.0
    @Published var minZoom: CGFloat = 1.0
    @Published var maxZoom: CGFloat = 10.0
    
    private let output = AVCapturePhotoOutput()
    private var videoInput: AVCaptureDeviceInput?
    private var currentExposureBias: Float = 0.0
    
    override init() {
        super.init()
        checkPermissions()
    }
    
    func checkPermissions() {
        switch AVCaptureDevice.authorizationStatus(for: .video) {
        case .notDetermined:
            AVCaptureDevice.requestAccess(for: .video) { granted in
                if granted { self.setupCamera() }
            }
        case .authorized:
            setupCamera()
        default: break
        }
    }
    
    func setupCamera() {
        DispatchQueue.global(qos: .userInitiated).async {
            self.session.beginConfiguration()
            if let device = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back),
               let input = try? AVCaptureDeviceInput(device: device) {
                self.videoInput = input
                if self.session.canAddInput(input) { self.session.addInput(input) }
                if self.session.canAddOutput(self.output) { self.session.addOutput(self.output) }

                // Initialize Exposure Limits
                DispatchQueue.main.async {
                    self.minExposure = device.minExposureTargetBias
                    self.maxExposure = device.maxExposureTargetBias
                    self.currentExposure = 0.0
                }

                // Initialize Zoom Limits
                DispatchQueue.main.async {
                    self.minZoom = device.minAvailableVideoZoomFactor
                    self.maxZoom = min(device.maxAvailableVideoZoomFactor, 10.0)
                    self.currentZoom = device.videoZoomFactor
                }

                // Enable continuous auto-focus by default
                self.enableContinuousAutoFocus()
            }
            self.session.commitConfiguration()
            self.session.startRunning()
            DispatchQueue.main.async {
                self.isSessionReady = true
            }
        }
    }

    // Enable continuous auto-focus and auto-exposure
    func enableContinuousAutoFocus() {
        guard let device = videoInput?.device else { return }
        do {
            try device.lockForConfiguration()

            if device.isFocusModeSupported(.continuousAutoFocus) {
                device.focusMode = .continuousAutoFocus
            }

            if device.isExposureModeSupported(.continuousAutoExposure) {
                device.exposureMode = .continuousAutoExposure
            }

            device.unlockForConfiguration()
        } catch {
            print("Failed to enable continuous auto-focus: \(error)")
        }
    }
    
    // Tap to Focus (One Shot)
    func focusAndExpose(at devicePoint: CGPoint) {
        guard let device = videoInput?.device else { return }
        do {
            try device.lockForConfiguration()

            if device.isFocusPointOfInterestSupported && device.isFocusModeSupported(.autoFocus) {
                device.focusPointOfInterest = devicePoint
                device.focusMode = .autoFocus
            }

            if device.isExposurePointOfInterestSupported && device.isExposureModeSupported(.autoExpose) {
                device.exposurePointOfInterest = devicePoint
                device.exposureMode = .autoExpose
                // Preserve current exposure bias - don't reset to 0
                device.setExposureTargetBias(currentExposure, completionHandler: nil)
            }

            device.unlockForConfiguration()
        } catch {
            print("Failed to lock for focus: \(error)")
        }
    }
    
    // Long Press to Lock (AE/AF Lock)
    func lockAEAF(at devicePoint: CGPoint) {
        guard let device = videoInput?.device else { return }
        do {
            try device.lockForConfiguration()

            if device.isFocusPointOfInterestSupported && device.isFocusModeSupported(.autoFocus) {
                device.focusPointOfInterest = devicePoint
                // Start autofocus, then it will lock when converged.
                // Alternatively, .locked is used to lock at current lens pos,
                // but usually we want to focus on the point *then* lock.
                // .autoFocus does exactly that: scan once, then stop (lock).
                device.focusMode = .autoFocus
            }

            if device.isExposurePointOfInterestSupported && device.isExposureModeSupported(.autoExpose) {
                device.exposurePointOfInterest = devicePoint
                device.exposureMode = .autoExpose
                // Preserve current exposure bias - don't reset to 0
                device.setExposureTargetBias(currentExposure, completionHandler: nil)
            }

            device.unlockForConfiguration()
        } catch {
            print("Failed to lock AE/AF: \(error)")
        }
    }
    
    func adjustExposure(delta: Float) {
        guard let device = videoInput?.device else { return }
        do {
            try device.lockForConfiguration()
            let newBias = max(device.minExposureTargetBias, min(device.maxExposureTargetBias, currentExposure + delta))
            device.setExposureTargetBias(newBias, completionHandler: nil)

            DispatchQueue.main.async {
                self.currentExposure = newBias
            }

            device.unlockForConfiguration()
        } catch {
            print("Failed to set exposure: \(error)")
        }
    }

    func setZoom(factor: CGFloat) {
        guard let device = videoInput?.device else { return }
        do {
            try device.lockForConfiguration()
            let clampedZoom = max(device.minAvailableVideoZoomFactor, min(min(device.maxAvailableVideoZoomFactor, 10.0), factor))
            device.videoZoomFactor = clampedZoom

            DispatchQueue.main.async {
                self.currentZoom = clampedZoom
            }

            device.unlockForConfiguration()
        } catch {
            print("Failed to set zoom: \(error)")
        }
    }
    
    func takePhoto() {
        let settings = AVCapturePhotoSettings()
        // Check if flash is supported
        if output.supportedFlashModes.contains(flashMode) {
            settings.flashMode = flashMode
        }
        output.capturePhoto(with: settings, delegate: self)
    }
    
    func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingPhoto photo: AVCapturePhoto, error: Error?) {
        guard let data = photo.fileDataRepresentation(), let image = UIImage(data: data) else { return }
        DispatchQueue.main.async {
            self.capturedImage = image
        }
    }
    
    func retake() {
        DispatchQueue.main.async { self.capturedImage = nil }
    }
    
    func flipCamera() {
        guard let input = videoInput else { return }
        session.beginConfiguration()
        session.removeInput(input)
        
        let newPosition: AVCaptureDevice.Position = input.device.position == .back ? .front : .back
        if let newDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: newPosition),
           let newInput = try? AVCaptureDeviceInput(device: newDevice) {
            if session.canAddInput(newInput) {
                session.addInput(newInput)
                videoInput = newInput
            } else {
                session.addInput(input)
            }
        } else {
            session.addInput(input)
        }
        
        // Refresh exposure limits for new device
        if let device = videoInput?.device {
            DispatchQueue.main.async {
                self.minExposure = device.minExposureTargetBias
                self.maxExposure = device.maxExposureTargetBias
                self.currentExposure = 0.0
                self.minZoom = device.minAvailableVideoZoomFactor
                self.maxZoom = min(device.maxAvailableVideoZoomFactor, 10.0)
                self.currentZoom = device.videoZoomFactor
            }
            // Re-enable continuous auto-focus for the new camera
            enableContinuousAutoFocus()
        }

        session.commitConfiguration()
    }
}

// MARK: - 1. CAMERA TAB UI
struct DentalCameraSetupView: View {
    @Binding var selectedTab: Int
    @ObservedObject var cameraService: CameraService

    // UI State
    @State private var showGrid = false
    @State private var ghostImage: UIImage? = nil
    @State private var ghostOpacity: Double = 0.5
    @State private var isGhostPickerPresented = false
    @State private var isOptionsExpanded = false // Unified Options Menu
    
    // Focus/Exposure State
    @State private var focusLocation: CGPoint? = nil
    @State private var showFocusSquare = false
    @State private var isAELocked = false
    @State private var showShutterEffect = false

    // Zoom State
    @State private var baseZoomFactor: CGFloat = 1.0
    @State private var showZoomDial = false
    @State private var zoomDialTimer: DispatchWorkItem?

    // Focus Square Timer
    @State private var focusSquareTimer: DispatchWorkItem?

    // Photo Metadata State (new unified system)
    @State private var currentMetadata = PhotoMetadata()
    @State private var isInfoPillOpen = false
    @ObservedObject var metadataManager = MetadataManager.shared

    // Photo Preview State
    @State private var lastSavedPhoto: UIImage? = nil
    @State private var lastSavedMetadata: PhotoMetadata? = nil
    @State private var lastSavedPhotoId: String? = nil
    @State private var showSuccessMessage = false
    @State private var showThumbnailGlow = false
    @State private var isPhotoFading = false

    // Blank fields warning state
    @State private var showBlankFieldsWarning = false

    // Check if any metadata field is blank
    var hasIncompleteMetadata: Bool {
        currentMetadata.procedure == nil ||
        currentMetadata.toothNumber == nil ||
        currentMetadata.stage == nil ||
        currentMetadata.angle == nil
    }

    // Save photo helper function
    func savePhotoWithMetadata() {
        guard let captured = cameraService.capturedImage else { return }

        // Save the photo and capture the photo ID
        PhotoLibraryManager.shared.saveWithMetadata(image: captured, metadata: currentMetadata) { photoId in
            lastSavedPhotoId = photoId
        }

        // Update preview and store metadata for navigation
        lastSavedPhoto = captured
        lastSavedMetadata = currentMetadata

        // Trigger fade-out animation
        isPhotoFading = true

        // Trigger thumbnail glow
        withAnimation(.spring(response: 0.4, dampingFraction: 0.6)) {
            showThumbnailGlow = true
        }

        // Return to camera after fade animation completes
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.25) {
            cameraService.retake()
            isPhotoFading = false
        }

        // Show success message
        withAnimation(.easeInOut(duration: 0.3)) {
            showSuccessMessage = true
        }

        // Hide thumbnail glow after animation
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.8) {
            withAnimation(.easeOut(duration: 0.3)) {
                showThumbnailGlow = false
            }
        }

        // Hide success message
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
            withAnimation(.easeInOut(duration: 0.3)) {
                showSuccessMessage = false
            }
        }
    }

    // Computed property for visual slider position
    // Maps actual exposure bias [min, max] to visual slider height [-70, 70]
    var exposureVisualOffset: CGFloat {
        let range = cameraService.maxExposure - cameraService.minExposure
        guard range > 0 else { return 0 }
        let percentage = (cameraService.currentExposure - cameraService.minExposure) / range
        let visualHeight: CGFloat = 140
        return (CGFloat(percentage) * visualHeight) - (visualHeight / 2)
    }
    
    var body: some View {
        NavigationView {
            ZStack {
                Color.black.ignoresSafeArea()

                // 1. CAMERA PREVIEW (Always active)
                CameraPreview(
                session: cameraService.session,
                onTap: { point in
                    isAELocked = false
                    showFocusSquare = true
                    cameraService.focusAndExpose(at: point)
                },
                onLongPress: { point in
                    isAELocked = true
                    cameraService.lockAEAF(at: point)
                    let generator = UINotificationFeedbackGenerator()
                    generator.notificationOccurred(.success)
                },
                onPan: { delta in
                    // Only allow exposure adjustment when focus box is visible
                    if showFocusSquare || isAELocked {
                        cameraService.adjustExposure(delta: Float(delta) * 0.005) // Reduced sensitivity by 50%

                        // Extend focus square linger time by 2x when adjusting exposure
                        if !isAELocked {
                            focusSquareTimer?.cancel()
                            let workItem = DispatchWorkItem {
                                if !isAELocked {
                                    withAnimation { showFocusSquare = false }
                                    // Re-enable continuous auto-focus after focus box disappears
                                    cameraService.enableContinuousAutoFocus()
                                }
                            }
                            focusSquareTimer = workItem
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.4, execute: workItem) // 2x default (1.2s)
                        }
                    }
                },
                onPinch: { scale in
                    if scale == 0.0 {
                        // Pinch gesture ended, update base zoom
                        baseZoomFactor = cameraService.currentZoom
                    } else {
                        // Pinch gesture in progress
                        let newZoom = baseZoomFactor * scale
                        cameraService.setZoom(factor: newZoom)

                        // Show zoom dial
                        showZoomDial = true
                        zoomDialTimer?.cancel()
                        let workItem = DispatchWorkItem {
                            withAnimation { showZoomDial = false }
                        }
                        zoomDialTimer = workItem
                        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5, execute: workItem)
                    }
                },
                touchPoint: $focusLocation
            )
            .ignoresSafeArea()
            
            // 1.5 CAPTURED IMAGE OVERLAY (Review Mode)
            if let captured = cameraService.capturedImage {
                GeometryReader { geometry in
                    Image(uiImage: captured)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(width: geometry.size.width, height: geometry.size.height)
                        .clipped()
                }
                .ignoresSafeArea()
                .zIndex(1)
                .opacity(isPhotoFading ? 0 : 1)
                .animation(.easeOut(duration: 0.25), value: isPhotoFading)
            }
            
            // 2. FOCUS INDICATOR
            if let loc = focusLocation, cameraService.capturedImage == nil {
                ZStack {
                    // Focus Box with Inner Ticks
                    ZStack {
                        Rectangle().stroke(Color.yellow, lineWidth: 1.5).frame(width: 75, height: 75)
                        Rectangle().fill(Color.yellow).frame(width: 1.5, height: 10).offset(y: -32.5)
                        Rectangle().fill(Color.yellow).frame(width: 1.5, height: 10).offset(y: 32.5)
                        Rectangle().fill(Color.yellow).frame(width: 10, height: 1.5).offset(x: -32.5)
                        Rectangle().fill(Color.yellow).frame(width: 10, height: 1.5).offset(x: 32.5)
                    }
                    .opacity(showFocusSquare || isAELocked ? 1 : 0)
                    
                    // Native-Style Exposure Slider
                    if showFocusSquare || isAELocked {
                        // Line above sun icon
                        let sunY = -exposureVisualOffset
                        let topLineHeight = max(0, 70 + sunY - 12) // From top (-70) to just above sun
                        let bottomLineHeight = max(0, 70 - sunY - 12) // From just below sun to bottom (+70)

                        // Top line segment (above sun)
                        if topLineHeight > 0 {
                            Rectangle()
                                .fill(Color.yellow)
                                .frame(width: 1, height: topLineHeight)
                                .offset(x: 65, y: -70 + topLineHeight / 2)
                                .shadow(radius: 1)
                                .opacity(0.8)
                        }

                        // Bottom line segment (below sun)
                        if bottomLineHeight > 0 {
                            Rectangle()
                                .fill(Color.yellow)
                                .frame(width: 1, height: bottomLineHeight)
                                .offset(x: 65, y: 70 - bottomLineHeight / 2)
                                .shadow(radius: 1)
                                .opacity(0.8)
                        }

                        Image(systemName: "sun.max.fill")
                            .font(.system(size: 20))
                            .foregroundColor(.yellow)
                            .shadow(radius: 2)
                            .offset(x: 65, y: sunY)
                    }
                }
                .position(loc)
                .id(loc)
                .transition(.opacity.animation(.easeInOut(duration: 0.2)))
                .onChange(of: loc) {
                    showFocusSquare = true
                    if !isAELocked {
                        focusSquareTimer?.cancel()
                        let workItem = DispatchWorkItem {
                            if !isAELocked {
                                withAnimation { showFocusSquare = false }
                                // Re-enable continuous auto-focus after focus box disappears
                                cameraService.enableContinuousAutoFocus()
                            }
                        }
                        focusSquareTimer = workItem
                        DispatchQueue.main.asyncAfter(deadline: .now() + 1.2, execute: workItem) // Default linger time
                    }
                }
                
                if isAELocked {
                    Text("AE/AF LOCK")
                        .font(AppFonts.caption).foregroundColor(.black)
                        .padding(.vertical, 4).padding(.horizontal, 8)
                        .background(Color.yellow).cornerRadius(4)
                        .padding(.top, 120)
                        .transition(.opacity)
                }
            }
            
            // 3. OVERLAYS (Only visible when NOT reviewing)
            if cameraService.capturedImage == nil {
                if let ghost = ghostImage {
                    Image(uiImage: ghost)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .opacity(ghostOpacity).allowsHitTesting(false).ignoresSafeArea()
                }
                if showGrid { CameraGridOverlay().allowsHitTesting(false) }

                // Zoom Dial
                if showZoomDial {
                    VStack {
                        Spacer()
                        ZoomDialView(
                            currentZoom: cameraService.currentZoom,
                            minZoom: cameraService.minZoom,
                            maxZoom: cameraService.maxZoom
                        )
                        .transition(.opacity.combined(with: .scale))
                        .padding(.bottom, 180)
                    }
                    .allowsHitTesting(false)
                }
            }
            
            // 4. CONTROLS LAYER
            VStack {
                // TOP BAR
                ZStack(alignment: .top) {
                    // Center: Unified Photo Info Pill with Blank Fields Warning
                    VStack(spacing: 8) {
                        PhotoInfoPillView(
                            metadata: $currentMetadata,
                            isDropdownOpen: $isInfoPillOpen
                        )

                        // Blank fields warning popup
                        if showBlankFieldsWarning {
                            VStack(spacing: 12) {
                                Text("Blank fields detected")
                                    .font(AppFonts.subheadline)
                                    .foregroundColor(AppColors.textPrimary)

                                HStack(spacing: 12) {
                                    Button(action: {
                                        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                                            showBlankFieldsWarning = false
                                            isInfoPillOpen = true
                                        }
                                    }) {
                                        Text("Add fields")
                                            .font(AppFonts.caption)
                                            .foregroundColor(.white)
                                            .padding(.horizontal, 16)
                                            .padding(.vertical, 8)
                                            .background(AppColors.primary)
                                            .cornerRadius(8)
                                    }

                                    Button(action: {
                                        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                                            showBlankFieldsWarning = false
                                        }
                                        savePhotoWithMetadata()
                                    }) {
                                        Text("Proceed anyways")
                                            .font(AppFonts.caption)
                                            .foregroundColor(AppColors.textSecondary)
                                            .padding(.horizontal, 16)
                                            .padding(.vertical, 8)
                                            .background(AppColors.secondary.opacity(0.3))
                                            .cornerRadius(8)
                                    }
                                }
                            }
                            .padding(.vertical, 12)
                            .padding(.horizontal, 16)
                            .background(AppColors.surface.opacity(0.95))
                            .cornerRadius(12)
                            .overlay(
                                RoundedRectangle(cornerRadius: 12)
                                    .stroke(AppColors.warning.opacity(0.5), lineWidth: 1)
                            )
                            .shadow(color: Color.black.opacity(0.2), radius: 8, x: 0, y: 4)
                            .transition(.asymmetric(
                                insertion: .scale(scale: 0.9, anchor: .top).combined(with: .opacity),
                                removal: .scale(scale: 0.95, anchor: .top).combined(with: .opacity)
                            ))
                        }
                    }
                    .zIndex(10)

                    // Right: Unified Options Button (Expanding Downward)
                    if cameraService.capturedImage == nil {
                        HStack {
                            Spacer()
                            VStack(alignment: .trailing, spacing: 10) {
                                Button(action: { withAnimation { isOptionsExpanded.toggle() } }) {
                                    Image(systemName: isOptionsExpanded ? "chevron.up.circle.fill" : "slider.horizontal.3")
                                        .font(.title2)
                                        .padding(10)
                                        .background(Color.black.opacity(0.6))
                                        .clipShape(Circle())
                                        .foregroundColor(.white)
                                }

                                if isOptionsExpanded {
                                    // Flash Toggle
                                    Button(action: {
                                        switch cameraService.flashMode {
                                        case .off: cameraService.flashMode = .on
                                        case .on: cameraService.flashMode = .auto
                                        default: cameraService.flashMode = .off
                                        }
                                    }) {
                                        Image(systemName: cameraService.flashMode == .off ? "bolt.slash.fill" : (cameraService.flashMode == .on ? "bolt.fill" : "bolt.badge.a.fill"))
                                            .font(.title2).padding(10)
                                            .background(Color.black.opacity(0.6)).clipShape(Circle()).foregroundColor(cameraService.flashMode == .off ? .white : .yellow)
                                    }
                                    .transition(.move(edge: .top).combined(with: .opacity))

                                    // Grid Toggle
                                    Button(action: { showGrid.toggle() }) {
                                        Image(systemName: showGrid ? "square" : "grid")
                                            .font(.title2).padding(10)
                                            .background(Color.black.opacity(0.6)).clipShape(Circle()).foregroundColor(showGrid ? .yellow : .white)
                                    }
                                    .transition(.move(edge: .top).combined(with: .opacity))

                                    // Ghost Toggle
                                    Button(action: {
                                        if ghostImage != nil { ghostImage = nil }
                                        else { isGhostPickerPresented = true }
                                    }) {
                                        Image(systemName: ghostImage != nil ? "xmark.square" : "square.on.square.dashed")
                                            .font(.title2).padding(10)
                                            .background(Color.black.opacity(0.6)).clipShape(Circle()).foregroundColor(ghostImage != nil ? .yellow : .white)
                                    }
                                    .transition(.move(edge: .top).combined(with: .opacity))
                                }
                            }
                        }
                    }
                }
                .padding(.horizontal)
                .padding(.top, 60)
                
                Spacer()
                
                // BOTTOM BAR
                if let captured = cameraService.capturedImage {
                    // REVIEW MODE
                    HStack(alignment: .center, spacing: 50) {
                        Button(action: {
                            isPhotoFading = true
                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.25) {
                                cameraService.retake()
                                isPhotoFading = false
                            }
                        }) {
                            Text("Retake")
                                .font(AppFonts.headline)
                                .frame(width: 120, height: 50)
                        }
                        .buttonStyle(CustomSecondaryButtonStyle())

                        Button(action: {
                            if hasIncompleteMetadata {
                                // Show blank fields warning
                                withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                                    showBlankFieldsWarning = true
                                }
                            } else {
                                savePhotoWithMetadata()
                            }
                        }) {
                            Text("Use Photo")
                                .font(AppFonts.headline)
                                .frame(width: 120, height: 50)
                        }
                        .buttonStyle(CustomPrimaryButtonStyle())
                    }
                    .frame(maxWidth: .infinity, alignment: .center)
                    .padding(.bottom, 100)
                } else {
                    // CAPTURE MODE
                    ZStack {
                        if ghostImage != nil {
                            VStack {
                                Slider(value: $ghostOpacity, in: 0.1...0.8).accentColor(.blue).frame(width: 200)
                                Spacer().frame(height: 180)
                            }
                        }

                        // Shutter Button (Center)
                        Button(action: {
                            withAnimation(.easeInOut(duration: 0.1)) { showShutterEffect = true }
                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                                withAnimation { showShutterEffect = false }
                            }
                            cameraService.takePhoto()
                        }) {
                            ZStack {
                                Circle().stroke(Color.white, lineWidth: 4).frame(width: 72, height: 72)
                                Circle().fill(Color.white).frame(width: 62, height: 62)
                            }
                        }
                        .padding(.bottom, 100)

                        // Bottom row: Photo Preview (left) and Flip Camera (right)
                        HStack {
                            // Last Photo Preview (bottom-left)
                            if let lastPhoto = lastSavedPhoto {
                                Button(action: {
                                    // Set navigation state and switch to gallery tab
                                    GalleryNavigationState.shared.setNavigation(
                                        procedure: lastSavedMetadata?.procedure,
                                        toothNumber: lastSavedMetadata?.toothNumber,
                                        toothDate: lastSavedMetadata?.toothDate,
                                        photoId: lastSavedPhotoId
                                    )
                                    selectedTab = 1
                                }) {
                                    Image(uiImage: lastPhoto)
                                        .resizable()
                                        .aspectRatio(contentMode: .fill)
                                        .frame(width: 50, height: 50)
                                        .clipShape(RoundedRectangle(cornerRadius: 8))
                                        .overlay(
                                            RoundedRectangle(cornerRadius: 8)
                                                .stroke(Color.white, lineWidth: showThumbnailGlow ? 3 : 2)
                                        )
                                        .shadow(color: .white.opacity(showThumbnailGlow ? 0.8 : 0), radius: 12)
                                        .shadow(color: .blue.opacity(showThumbnailGlow ? 0.6 : 0), radius: 16)
                                        .scaleEffect(showThumbnailGlow ? 1.3 : 1.0)
                                }
                                .padding(.leading, 20)
                            } else {
                                // Placeholder when no photo saved yet
                                RoundedRectangle(cornerRadius: 8)
                                    .fill(Color.gray.opacity(0.3))
                                    .frame(width: 50, height: 50)
                                    .overlay(
                                        Image(systemName: "photo")
                                            .foregroundColor(.gray)
                                    )
                                    .padding(.leading, 20)
                            }

                            Spacer()

                            // Flip Camera Button (bottom-right) - matches thumbnail size
                            Button(action: { cameraService.flipCamera() }) {
                                Image(systemName: "arrow.triangle.2.circlepath.camera")
                                    .font(.system(size: 22))
                                    .foregroundColor(.white)
                                    .frame(width: 50, height: 50)
                                    .background(Color.black.opacity(0.6))
                                    .clipShape(Circle())
                            }
                            .padding(.trailing, 20)
                        }
                        .padding(.bottom, 76) // Positioned to maintain 18pt gap to nav bar top
                    }
                }
            }
            .zIndex(2)

            // Success message overlay
            if showSuccessMessage {
                VStack {
                    HStack(spacing: 8) {
                        Image(systemName: "checkmark.circle.fill")
                            .foregroundColor(.white)
                        Text("Photo stored successfully")
                            .font(AppFonts.caption)
                            .foregroundColor(.white)
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 10)
                    .background(AppColors.success)
                    .cornerRadius(20)
                    .shadow(radius: 5)

                    Spacer()
                }
                .padding(.top, 120)
                .transition(.move(edge: .top).combined(with: .opacity))
                .zIndex(25)
            }

            // SHUTTER EFFECT FLASH
            if showShutterEffect {
                Color.black.ignoresSafeArea().zIndex(20)
            }
        }
            .ignoresSafeArea()
            .sheet(isPresented: $isGhostPickerPresented) {
                CustomGhostPicker(selectedImage: $ghostImage)
            }
            .navigationBarHidden(true)
        }
        .navigationViewStyle(StackNavigationViewStyle())
    }
}

// MARK: - CAMERA PREVIEW & INTERACTION
struct CameraPreview: UIViewRepresentable {
    var session: AVCaptureSession
    var onTap: (CGPoint) -> Void
    var onLongPress: (CGPoint) -> Void
    var onPan: (CGFloat) -> Void
    var onPinch: (CGFloat) -> Void
    @Binding var touchPoint: CGPoint?
    
    class VideoPreviewView: UIView {
        override class var layerClass: AnyClass { AVCaptureVideoPreviewLayer.self }
        var videoPreviewLayer: AVCaptureVideoPreviewLayer { return layer as! AVCaptureVideoPreviewLayer }
    }
    
    func makeUIView(context: Context) -> VideoPreviewView {
        let view = VideoPreviewView()
        view.backgroundColor = .black
        view.videoPreviewLayer.session = session
        view.videoPreviewLayer.videoGravity = .resizeAspectFill
        view.videoPreviewLayer.connection?.videoRotationAngle = 90
        
        // Tap Gesture
        let tap = UITapGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handleTap(_:)))
        view.addGestureRecognizer(tap)
        
        // Long Press Gesture
        let longPress = UILongPressGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handleLongPress(_:)))
        longPress.minimumPressDuration = 1.0 // Increased to 1.0s
        view.addGestureRecognizer(longPress)
        
        // Pan Gesture (Vertical drag for exposure)
        let pan = UIPanGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handlePan(_:)))
        view.addGestureRecognizer(pan)

        // Pinch Gesture (Zoom)
        let pinch = UIPinchGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handlePinch(_:)))
        view.addGestureRecognizer(pinch)

        return view
    }
    
    func updateUIView(_ uiView: VideoPreviewView, context: Context) {}
    
    func makeCoordinator() -> Coordinator { Coordinator(self) }
    
    class Coordinator: NSObject {
        var parent: CameraPreview

        init(_ parent: CameraPreview) { self.parent = parent }

        @objc func handleTap(_ gesture: UITapGestureRecognizer) {
            guard let view = gesture.view as? VideoPreviewView else { return }
            let location = gesture.location(in: view)
            parent.touchPoint = location
            let devicePoint = view.videoPreviewLayer.captureDevicePointConverted(fromLayerPoint: location)
            parent.onTap(devicePoint)
        }

        @objc func handleLongPress(_ gesture: UILongPressGestureRecognizer) {
            if gesture.state == .began {
                guard let view = gesture.view as? VideoPreviewView else { return }
                let location = gesture.location(in: view)
                parent.touchPoint = location
                let devicePoint = view.videoPreviewLayer.captureDevicePointConverted(fromLayerPoint: location)
                parent.onLongPress(devicePoint)
            }
        }

        @objc func handlePan(_ gesture: UIPanGestureRecognizer) {
            let translation = gesture.translation(in: gesture.view)
            // Vertical movement controls exposure
            parent.onPan(-translation.y)
            gesture.setTranslation(.zero, in: gesture.view)
        }

        @objc func handlePinch(_ gesture: UIPinchGestureRecognizer) {
            if gesture.state == .began || gesture.state == .changed {
                // Pass cumulative scale since gesture began (don't reset gesture.scale)
                parent.onPinch(gesture.scale)
            } else if gesture.state == .ended || gesture.state == .cancelled {
                parent.onPinch(0.0) // Signal end of pinch with 0.0
            }
        }
    }
}

struct CameraGridOverlay: View {
    var body: some View {
        GeometryReader { geometry in
            Path { path in
                let width = geometry.size.width
                let height = geometry.size.height
                path.move(to: CGPoint(x: width/3, y: 0)); path.addLine(to: CGPoint(x: width/3, y: height))
                path.move(to: CGPoint(x: 2*width/3, y: 0)); path.addLine(to: CGPoint(x: 2*width/3, y: height))
                path.move(to: CGPoint(x: 0, y: height/3)); path.addLine(to: CGPoint(x: width, y: height/3))
                path.move(to: CGPoint(x: 0, y: 2*height/3)); path.addLine(to: CGPoint(x: width, y: 2*height/3))
            }
            .stroke(Color.white.opacity(0.5), lineWidth: 1)
        }
        .aspectRatio(3/4, contentMode: .fit)
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

struct ZoomDialView: View {
    let currentZoom: CGFloat
    let minZoom: CGFloat
    let maxZoom: CGFloat

    // Fixed display range from 1x to 10x
    private let displayMin: CGFloat = 1.0
    private let displayMax: CGFloat = 10.0

    // Total width of the tick strip content
    private let stripContentWidth: CGFloat = 450
    // Visible width (2/3 of typical screen width ~250pt)
    private let visibleWidth: CGFloat = 250

    var normalizedZoom: CGFloat {
        // Normalize current zoom to 0-1 range based on display range (1-10)
        let clamped = min(max(currentZoom, displayMin), displayMax)
        return (clamped - displayMin) / (displayMax - displayMin)
    }

    var scrollOffset: CGFloat {
        // Calculate offset so indicator aligns with correct tick
        // At zoom 1.0 (normalizedZoom=0), tick 0 ("1" label) should be at center
        // At zoom 10.0 (normalizedZoom=1), tick 90 ("10" label) should be at center
        let tickSpacing: CGFloat = 5
        let firstTickCenter: CGFloat = tickSpacing / 2  // 2.5pt
        let lastTickCenter: CGFloat = 90 * tickSpacing + tickSpacing / 2  // 452.5pt
        let tickRange = lastTickCenter - firstTickCenter  // 450pt

        let targetTickPosition = firstTickCenter + normalizedZoom * tickRange
        return (visibleWidth / 2) - targetTickPosition
    }

    var body: some View {
        VStack(spacing: 4) {
            // Zoom value display
            Text(String(format: "%.1fx", currentZoom))
                .font(AppFonts.interSemiBold(14))
                .foregroundColor(.yellow)

            // Horizontal strip with tick marks
            ZStack {
                // Tick marks strip that scrolls - 90 ticks for 1-10 range (10 per integer)
                HStack(spacing: 0) {
                    ForEach(0..<91) { i in
                        // Each 10 ticks = 1 zoom level (0=1x, 10=2x, 20=3x, ... 90=10x)
                        let isMainTick = i % 10 == 0  // Integer zoom values
                        let isMidTick = i % 5 == 0 && !isMainTick  // Half-integer values
                        let tickHeight: CGFloat = isMainTick ? 16 : (isMidTick ? 10 : 6)
                        let tickWidth: CGFloat = isMainTick ? 2 : 1

                        VStack(spacing: 1) {
                            Rectangle()
                                .fill(Color.white)
                                .frame(width: tickWidth, height: tickHeight)

                            // Show zoom labels at integer values (1, 2, 3, ... 10)
                            if isMainTick {
                                let zoomValue = Int(displayMin) + (i / 10)
                                Text("\(zoomValue)")
                                    .font(AppFonts.geistMedium(8))
                                    .foregroundColor(.white.opacity(0.8))
                            }
                        }
                        .frame(width: 5) // Spacing between ticks
                    }
                }
                .offset(x: scrollOffset)

                // Fade edges with gradient masks
                HStack {
                    LinearGradient(
                        gradient: Gradient(colors: [Color.black, Color.black.opacity(0)]),
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                    .frame(width: 40)

                    Spacer()

                    LinearGradient(
                        gradient: Gradient(colors: [Color.black.opacity(0), Color.black]),
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                    .frame(width: 40)
                }

                // Center indicator
                VStack(spacing: 0) {
                    Triangle()
                        .fill(Color.yellow)
                        .frame(width: 8, height: 6)
                    Rectangle()
                        .fill(Color.yellow)
                        .frame(width: 2, height: 18)
                }
            }
            .frame(width: visibleWidth, height: 38)
            .clipped()
        }
        .padding(.vertical, 6)
        .padding(.horizontal, 12)
        .background(Color.black.opacity(0.6))
        .cornerRadius(10)
    }
}

// Triangle shape for the indicator
struct Triangle: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        path.move(to: CGPoint(x: rect.midX, y: rect.maxY))
        path.addLine(to: CGPoint(x: rect.minX, y: rect.minY))
        path.addLine(to: CGPoint(x: rect.maxX, y: rect.minY))
        path.closeSubpath()
        return path
    }
}

// MARK: - PHOTO INFO PILL VIEW
enum PhotoInfoStage: Int, CaseIterable {
    case procedure = 0
    case tooth = 1
    case stage = 2
    case angle = 3
    case complete = 4

    var prompt: String {
        switch self {
        case .procedure: return "Choose procedure"
        case .tooth: return "Choose tooth"
        case .stage: return "Choose stage"
        case .angle: return "Choose angle"
        case .complete: return ""
        }
    }
}

struct PhotoInfoPillView: View {
    @Binding var metadata: PhotoMetadata
    @Binding var isDropdownOpen: Bool
    @ObservedObject var metadataManager = MetadataManager.shared

    @State private var currentStage: PhotoInfoStage = .procedure
    @State private var newProcedureText: String = ""
    @State private var selectedToothNumber: Int = 1
    @State private var selectedToothDate: Date = Date()
    @State private var showNewToothEntry: Bool = false

    private let stageColors: [PhotoInfoStage: Color] = [
        .procedure: .blue,
        .tooth: .green,
        .stage: .orange,
        .angle: .purple
    ]

    // Check if any required metadata field is blank
    var hasIncompleteFields: Bool {
        metadata.procedure == nil ||
        metadata.toothNumber == nil ||
        metadata.stage == nil ||
        metadata.angle == nil
    }

    // Computed properties for pill styling (helps Swift type-checker)
    var pillStrokeColor: Color {
        if hasIncompleteFields {
            return Color.red.opacity(0.8)
        } else if isDropdownOpen {
            return Color.blue
        } else {
            return Color.white.opacity(0.3)
        }
    }

    var pillStrokeWidth: CGFloat {
        hasIncompleteFields ? 1.5 : 1
    }

    var pillGlowColor: Color {
        hasIncompleteFields ? Color.red.opacity(0.4) : Color.clear
    }

    var pillGlowColorOuter: Color {
        hasIncompleteFields ? Color.red.opacity(0.2) : Color.clear
    }

    var body: some View {
        VStack(spacing: 0) {
            // Main pill button
            Button(action: { withAnimation { isDropdownOpen.toggle() } }) {
                HStack(spacing: 6) {
                    // Show current selections with visual hierarchy
                    if metadata.procedure == nil {
                        Text("Choose procedure")
                            .font(AppFonts.caption)
                            .foregroundColor(.white.opacity(0.7))
                    } else {
                        // Procedure badge
                        Text(metadata.procedure ?? "")
                            .font(AppFonts.geistSemiBold(11))
                            .padding(.horizontal, 6)
                            .padding(.vertical, 2)
                            .background(AppColors.primary.opacity(0.8))
                            .cornerRadius(4)

                        if let tooth = metadata.toothNumber {
                            Text("#\(tooth)")
                                .font(AppFonts.geistSemiBold(11))
                                .padding(.horizontal, 4)
                                .padding(.vertical, 2)
                                .background(AppColors.success.opacity(0.8))
                                .cornerRadius(4)
                        }

                        if let stage = metadata.stage {
                            Text(String(stage.prefix(4)))
                                .font(AppFonts.caption2)
                                .padding(.horizontal, 4)
                                .padding(.vertical, 2)
                                .background(AppColors.warning.opacity(0.8))
                                .cornerRadius(4)
                        }

                        if let angle = metadata.angle {
                            Text(angle)
                                .font(AppFonts.caption2)
                                .padding(.horizontal, 4)
                                .padding(.vertical, 2)
                                .background(Color.purple.opacity(0.8))
                                .cornerRadius(4)
                        }
                    }

                    Image(systemName: isDropdownOpen ? "chevron.up" : "chevron.down")
                        .font(AppFonts.caption2)
                        .foregroundColor(.white.opacity(0.7))
                }
                .padding(.vertical, 8)
                .padding(.horizontal, 12)
                .background(AppColors.surface.opacity(0.9))
                .cornerRadius(20)
                .overlay(
                    RoundedRectangle(cornerRadius: 20)
                        .stroke(pillStrokeColor, lineWidth: pillStrokeWidth)
                )
                .shadow(color: pillGlowColor, radius: 8)
                .shadow(color: pillGlowColorOuter, radius: 16)
            }
            .foregroundColor(.white)

            // Dropdown content
            if isDropdownOpen {
                dropdownContent
                    .padding(.top, 8)
                    .transition(.asymmetric(
                        insertion: .scale(scale: 0.9, anchor: .top).combined(with: .opacity),
                        removal: .scale(scale: 0.95, anchor: .top).combined(with: .opacity)
                    ))
            }
        }
    }

    var dropdownContent: some View {
        VStack(alignment: .leading, spacing: 0) {
            stageTabsView
            Divider().background(AppColors.secondary.opacity(0.3)).padding(.vertical, 8)
            currentStageContentView
            Divider().background(AppColors.secondary.opacity(0.3))
            bottomButtonsView
        }
        .frame(width: 340)
        .background(AppColors.surface.opacity(0.98))
        .cornerRadius(12)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(AppColors.secondary.opacity(0.3), lineWidth: 1)
        )
        .onAppear { updateCurrentStage() }
    }

    // MARK: - Dropdown Sub-views
    var stageTabsView: some View {
        HStack(spacing: 4) {
            ForEach([PhotoInfoStage.procedure, .tooth, .stage, .angle], id: \.self) { stage in
                stageTabButton(for: stage)
            }
        }
        .padding(.horizontal, 8)
        .padding(.top, 8)
    }

    func stageTabButton(for stage: PhotoInfoStage) -> some View {
        Button(action: {
            withAnimation { currentStage = stage }
        }) {
            VStack(spacing: 4) {
                Text(stageName(for: stage))
                    .font(AppFonts.geistSemiBold(11))
                    .foregroundColor(currentStage == stage ? AppColors.textPrimary : AppColors.textSecondary)
                Text(stageValue(for: stage))
                    .font(AppFonts.geistRegular(9))
                    .foregroundColor(stageColor(for: stage))
                    .lineLimit(1)
                    .truncationMode(.tail)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 6)
            .background(currentStage == stage ? stageColor(for: stage).opacity(0.3) : AppColors.secondary.opacity(0.1))
            .cornerRadius(8)
            .overlay(
                RoundedRectangle(cornerRadius: 8)
                    .stroke(currentStage == stage ? stageColor(for: stage) : Color.clear, lineWidth: 1)
            )
        }
    }

    @ViewBuilder
    var currentStageContentView: some View {
        VStack(alignment: .leading, spacing: 4) {
            switch currentStage {
            case .procedure:
                procedureStageContent
            case .tooth:
                toothStageContent
            case .stage:
                stageStageContent
            case .angle:
                angleStageContent
            case .complete:
                EmptyView()
            }
        }
        .padding(.horizontal, 8)
    }

    var bottomButtonsView: some View {
        HStack {
            Button(action: { clearAllMetadata() }) {
                HStack(spacing: 4) {
                    Image(systemName: "xmark.circle")
                    Text("Clear all")
                }
                .font(AppFonts.caption)
                .foregroundColor(AppColors.error)
            }

            Spacer()

            if currentStage.rawValue > 0 {
                Button(action: { navigateToPreviousStage() }) {
                    Image(systemName: "chevron.left")
                        .font(AppFonts.caption)
                        .foregroundColor(AppColors.primary)
                }
            }

            if currentStage.rawValue < 3 {
                Button(action: { navigateToNextStage() }) {
                    Image(systemName: "chevron.right")
                        .font(AppFonts.caption)
                        .foregroundColor(AppColors.primary)
                }
            }
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 8)
    }

    func navigateToPreviousStage() {
        withAnimation {
            if let prev = PhotoInfoStage(rawValue: currentStage.rawValue - 1) {
                currentStage = prev
            }
        }
    }

    func navigateToNextStage() {
        withAnimation {
            if let next = PhotoInfoStage(rawValue: currentStage.rawValue + 1) {
                currentStage = next
            }
        }
    }

    func stageName(for stage: PhotoInfoStage) -> String {
        switch stage {
        case .procedure: return "Procedure"
        case .tooth: return "Tooth"
        case .stage: return "Stage"
        case .angle: return "Angle"
        case .complete: return ""
        }
    }

    func stageValue(for stage: PhotoInfoStage) -> String {
        switch stage {
        case .procedure: return metadata.procedure ?? "Not set"
        case .tooth: return metadata.toothNumber != nil ? "#\(metadata.toothNumber!)" : "Not set"
        case .stage: return metadata.stage ?? "Not set"
        case .angle: return metadata.angle ?? "Not set"
        case .complete: return ""
        }
    }

    func stageColor(for stage: PhotoInfoStage) -> Color {
        switch stage {
        case .procedure: return metadata.procedure != nil ? .blue : .gray
        case .tooth: return metadata.toothNumber != nil ? .green : .gray
        case .stage: return metadata.stage != nil ? .orange : .gray
        case .angle: return metadata.angle != nil ? .purple : .gray
        case .complete: return .gray
        }
    }

    func clearAllMetadata() {
        withAnimation {
            metadata.procedure = nil
            metadata.toothNumber = nil
            metadata.toothDate = nil
            metadata.stage = nil
            metadata.angle = nil
            metadata.rating = nil
            currentStage = .procedure
            showNewToothEntry = false
        }
    }

    // MARK: - Stage 1: Procedure Selection
    var procedureStageContent: some View {
        VStack(alignment: .leading, spacing: 4) {
            ForEach(metadataManager.procedures, id: \.self) { procedure in
                Button(action: {
                    metadata.procedure = procedure
                    advanceToNextStage()
                }) {
                    HStack {
                        Image(systemName: metadata.procedure == procedure ? "circle.inset.filled" : "circle")
                            .foregroundColor(AppColors.primary)
                        Text(procedure)
                            .font(AppFonts.subheadline)
                            .foregroundColor(AppColors.textPrimary)
                        Spacer()
                    }
                    .padding(.vertical, 8)
                    .padding(.horizontal, 8)
                    .background(metadata.procedure == procedure ? AppColors.primary.opacity(0.2) : Color.clear)
                    .cornerRadius(6)
                }
            }

            // Add new procedure
            Divider().background(AppColors.secondary.opacity(0.3)).padding(.vertical, 4)
            HStack(spacing: 8) {
                TextField("Add new...", text: $newProcedureText)
                    .font(AppFonts.caption)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .background(AppColors.surfaceElevated)
                    .cornerRadius(8)
                    .foregroundColor(AppColors.textPrimary)

                Button(action: {
                    if !newProcedureText.isEmpty {
                        metadataManager.addProcedure(newProcedureText)
                        metadata.procedure = newProcedureText
                        newProcedureText = ""
                        advanceToNextStage()
                    }
                }) {
                    Image(systemName: "plus.circle.fill")
                        .foregroundColor(AppColors.success)
                }
                .disabled(newProcedureText.isEmpty)
            }
            .padding(.horizontal, 4)
        }
    }

    // MARK: - Stage 2: Tooth Selection
    var toothStageContent: some View {
        VStack(alignment: .leading, spacing: 8) {
            let existingTeeth = metadataManager.getToothEntries(for: metadata.procedure ?? "")

            if !existingTeeth.isEmpty && !showNewToothEntry {
                // Show previously entered teeth
                Text("Previous teeth:")
                    .font(AppFonts.caption2)
                    .foregroundColor(AppColors.textSecondary)
                    .padding(.horizontal, 4)

                ForEach(existingTeeth) { entry in
                    Button(action: {
                        metadata.toothNumber = entry.toothNumber
                        metadata.toothDate = entry.date
                        advanceToNextStage()
                    }) {
                        HStack {
                            Image(systemName: "tooth")
                                .foregroundColor(AppColors.success)
                            Text(entry.displayString)
                                .font(AppFonts.subheadline)
                                .foregroundColor(AppColors.textPrimary)
                            Spacer()
                        }
                        .padding(.vertical, 8)
                        .padding(.horizontal, 8)
                        .background(AppColors.success.opacity(0.1))
                        .cornerRadius(6)
                    }
                }

                Divider().background(AppColors.secondary.opacity(0.3)).padding(.vertical, 4)

                Button(action: { showNewToothEntry = true }) {
                    HStack {
                        Image(systemName: "plus.circle")
                            .foregroundColor(AppColors.primary)
                        Text("Enter new tooth")
                            .font(AppFonts.subheadline)
                            .foregroundColor(AppColors.primary)
                    }
                    .padding(.vertical, 8)
                    .padding(.horizontal, 8)
                }
            } else {
                // New tooth entry form
                newToothEntryForm
            }
        }
    }

    var newToothEntryForm: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Tooth number picker - Static label with number wheel and name on right
            HStack(spacing: 8) {
                Text("Tooth #")
                    .font(AppFonts.title3)
                    .foregroundColor(AppColors.textPrimary)

                Picker("", selection: $selectedToothNumber) {
                    ForEach(1...32, id: \.self) { num in
                        Text("\(num)")
                            .tag(num)
                    }
                }
                .pickerStyle(.wheel)
                .frame(width: 55, height: 80)
                .clipped()

                // Tooth name display with fade animation
                Text(toothName(for: selectedToothNumber))
                    .font(AppFonts.caption)
                    .foregroundColor(AppColors.success)
                    .padding(.horizontal, 10)
                    .padding(.vertical, 6)
                    .background(AppColors.success.opacity(0.15))
                    .cornerRadius(6)
                    .id(selectedToothNumber) // Forces view recreation for animation
                    .transition(.opacity.animation(.easeInOut(duration: 0.2)))
                    .animation(.easeInOut(duration: 0.25), value: selectedToothNumber)
            }

            // Date picker
            VStack(alignment: .leading, spacing: 4) {
                Text("Date")
                    .font(AppFonts.caption2)
                    .foregroundColor(AppColors.textSecondary)

                DatePicker("", selection: $selectedToothDate, displayedComponents: .date)
                    .labelsHidden()
                    .colorScheme(.dark)
            }

            // Confirm button
            Button(action: {
                metadata.toothNumber = selectedToothNumber
                metadata.toothDate = selectedToothDate
                showNewToothEntry = false
                advanceToNextStage()
            }) {
                Text("Confirm Tooth #\(selectedToothNumber)")
                    .font(AppFonts.caption)
                    .foregroundColor(AppColors.textPrimary)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 10)
            }
            .buttonStyle(CustomPrimaryButtonStyle(backgroundColor: AppColors.success))

            if metadataManager.getToothEntries(for: metadata.procedure ?? "").count > 0 {
                Button(action: { showNewToothEntry = false }) {
                    Text("Cancel")
                        .font(AppFonts.caption)
                        .foregroundColor(AppColors.textSecondary)
                        .frame(maxWidth: .infinity)
                }
            }
        }
        .padding(.horizontal, 4)
    }

    func toothName(for number: Int) -> String {
        switch number {
        case 1: return "Maxillary Right 3rd Molar"
        case 2: return "Maxillary Right 2nd Molar"
        case 3: return "Maxillary Right 1st Molar"
        case 4: return "Maxillary Right 2nd Premolar"
        case 5: return "Maxillary Right 1st Premolar"
        case 6: return "Maxillary Right Canine"
        case 7: return "Maxillary Right Lateral Incisor"
        case 8: return "Maxillary Right Central Incisor"
        case 9: return "Maxillary Left Central Incisor"
        case 10: return "Maxillary Left Lateral Incisor"
        case 11: return "Maxillary Left Canine"
        case 12: return "Maxillary Left 1st Premolar"
        case 13: return "Maxillary Left 2nd Premolar"
        case 14: return "Maxillary Left 1st Molar"
        case 15: return "Maxillary Left 2nd Molar"
        case 16: return "Maxillary Left 3rd Molar"
        case 17: return "Mandibular Left 3rd Molar"
        case 18: return "Mandibular Left 2nd Molar"
        case 19: return "Mandibular Left 1st Molar"
        case 20: return "Mandibular Left 2nd Premolar"
        case 21: return "Mandibular Left 1st Premolar"
        case 22: return "Mandibular Left Canine"
        case 23: return "Mandibular Left Lateral Incisor"
        case 24: return "Mandibular Left Central Incisor"
        case 25: return "Mandibular Right Central Incisor"
        case 26: return "Mandibular Right Lateral Incisor"
        case 27: return "Mandibular Right Canine"
        case 28: return "Mandibular Right 1st Premolar"
        case 29: return "Mandibular Right 2nd Premolar"
        case 30: return "Mandibular Right 1st Molar"
        case 31: return "Mandibular Right 2nd Molar"
        case 32: return "Mandibular Right 3rd Molar"
        default: return "Unknown"
        }
    }

    // MARK: - Stage 3: Stage Selection (Preparation/Restoration)
    var stageStageContent: some View {
        VStack(alignment: .leading, spacing: 4) {
            ForEach(metadataManager.stages, id: \.self) { stage in
                Button(action: {
                    metadata.stage = stage
                    advanceToNextStage()
                }) {
                    HStack {
                        Image(systemName: stage == "Preparation" ? "wrench.and.screwdriver" : "checkmark.seal")
                            .foregroundColor(stage == "Preparation" ? AppColors.warning : AppColors.success)
                        Text(stage)
                            .font(AppFonts.subheadline)
                            .foregroundColor(AppColors.textPrimary)
                        Spacer()
                        if metadata.stage == stage {
                            Image(systemName: "checkmark")
                                .foregroundColor(AppColors.primary)
                        }
                    }
                    .padding(.vertical, 10)
                    .padding(.horizontal, 8)
                    .background(metadata.stage == stage ? AppColors.primary.opacity(0.2) : Color.clear)
                    .cornerRadius(6)
                }
            }
        }
    }

    // MARK: - Stage 4: Angle Selection
    var angleStageContent: some View {
        VStack(alignment: .leading, spacing: 4) {
            ForEach(metadataManager.angles, id: \.self) { angle in
                Button(action: {
                    metadata.angle = angle
                    advanceToNextStage()
                }) {
                    HStack {
                        Image(systemName: angleIcon(for: angle))
                            .foregroundColor(.purple)
                        Text(angle)
                            .font(AppFonts.subheadline)
                            .foregroundColor(AppColors.textPrimary)
                        Spacer()
                        if metadata.angle == angle {
                            Image(systemName: "checkmark")
                                .foregroundColor(AppColors.primary)
                        }
                    }
                    .padding(.vertical, 8)
                    .padding(.horizontal, 8)
                    .background(metadata.angle == angle ? AppColors.primary.opacity(0.2) : Color.clear)
                    .cornerRadius(6)
                }
            }
        }
    }

    func angleIcon(for angle: String) -> String {
        switch angle {
        case "Occlusal": return "arrow.down.circle"
        case "Buccal/Facial": return "arrow.left.circle"
        case "Lingual": return "arrow.right.circle"
        case "Proximal": return "arrow.left.arrow.right.circle"
        case "Mesial": return "arrow.up.left.circle"
        case "Distal": return "arrow.up.right.circle"
        default: return "questionmark.circle"
        }
    }

    // MARK: - Navigation
    func updateCurrentStage() {
        // When reopening, go to the first incomplete stage, or stay on procedure if all complete
        if metadata.procedure == nil {
            currentStage = .procedure
        } else if metadata.toothNumber == nil {
            currentStage = .tooth
        } else if metadata.stage == nil {
            currentStage = .stage
        } else if metadata.angle == nil {
            currentStage = .angle
        } else {
            // All fields complete - default to procedure tab for editing
            currentStage = .procedure
        }
    }

    func advanceToNextStage() {
        withAnimation {
            if let next = PhotoInfoStage(rawValue: currentStage.rawValue + 1) {
                if next == .complete {
                    // All done - close dropdown
                    isDropdownOpen = false
                    currentStage = .procedure
                } else {
                    currentStage = next
                }
            }
        }
    }

    func goToPreviousStage() {
        withAnimation {
            if currentStage.rawValue > 0 {
                // Clear the current stage's data
                switch currentStage {
                case .tooth:
                    metadata.procedure = nil
                case .stage:
                    metadata.toothNumber = nil
                    metadata.toothDate = nil
                    showNewToothEntry = false
                case .angle:
                    metadata.stage = nil
                case .complete:
                    metadata.angle = nil
                default:
                    break
                }
                currentStage = PhotoInfoStage(rawValue: currentStage.rawValue - 1) ?? .procedure
            }
        }
    }
}

// MARK: - 3. GALLERY TAB & EDITOR
struct GalleryView: View {
    @StateObject private var library = PhotoLibraryManager.shared
    @ObservedObject var metadataManager = MetadataManager.shared
    @ObservedObject var galleryNavState = GalleryNavigationState.shared
    @State private var isSidebarOpen = false
    @State private var selectedProcedure: String? = nil
    @State private var selectedTooth: ToothEntry? = nil
    @State private var expandedAngleStack: String? = nil

    // State for photo highlight animation
    @State private var showPhotoHighlight = false
    @State private var highlightedPhotoId: String? = nil

    // Folder management state
    @State private var showAddFolderSheet = false
    @State private var newFolderName = ""
    @State private var showDeleteConfirmation = false
    @State private var folderToDelete: String? = nil
    @State private var showRenameSheet = false
    @State private var folderToRename: String? = nil
    @State private var renameFolderText = ""
    @State private var showColorPicker = false
    @State private var folderForColorEdit: String? = nil

    // Stage collapse state
    @State private var collapsedStages: Set<String> = []

    // Swipe gesture state
    @State private var dragOffset: CGFloat = 0
    @GestureState private var isDraggingFromEdge = false

    let columns = [GridItem(.flexible()), GridItem(.flexible()), GridItem(.flexible())]

    // Get unique tooth entries for the selected procedure
    var toothEntriesForProcedure: [ToothEntry] {
        guard let proc = selectedProcedure else { return [] }
        return metadataManager.getToothEntries(for: proc)
    }

    // Get assets filtered by current selection
    var filteredAssets: [PHAsset] {
        var assets = library.assets
        if let proc = selectedProcedure {
            assets = assets.filter {
                metadataManager.getMetadata(for: $0.localIdentifier)?.procedure == proc
            }
        }
        if let tooth = selectedTooth {
            assets = assets.filter { asset in
                guard let meta = metadataManager.getMetadata(for: asset.localIdentifier) else { return false }
                return meta.toothNumber == tooth.toothNumber &&
                       meta.toothDate != nil &&
                       Calendar.current.isDate(meta.toothDate!, inSameDayAs: tooth.date)
            }
        }
        return assets
    }

    // Group assets by stage (Preparation/Restoration)
    var assetsByStage: [String: [PHAsset]] {
        var grouped: [String: [PHAsset]] = ["Preparation": [], "Restoration": []]
        for asset in filteredAssets {
            if let stage = metadataManager.getMetadata(for: asset.localIdentifier)?.stage {
                grouped[stage, default: []].append(asset)
            } else {
                grouped["Preparation", default: []].append(asset)
            }
        }
        return grouped
    }

    // Current section title for header
    var currentSectionTitle: String {
        if let tooth = selectedTooth {
            return "Tooth \(tooth.toothNumber)"
        } else if let proc = selectedProcedure {
            return proc
        } else {
            return "All Photos"
        }
    }

    // Group assets by angle within a stage, sorted by average rating
    func assetsByAngle(for stage: String) -> [(angle: String, assets: [PHAsset], avgRating: Double)] {
        let stageAssets = assetsByStage[stage] ?? []
        var grouped: [String: [PHAsset]] = [:]

        for asset in stageAssets {
            let angle = metadataManager.getMetadata(for: asset.localIdentifier)?.angle ?? "Other"
            grouped[angle, default: []].append(asset)
        }

        return grouped.map { (angle, assets) in
            let ratings = assets.compactMap { metadataManager.getRating(for: $0.localIdentifier) }
            let avg = ratings.isEmpty ? 0.0 : Double(ratings.reduce(0, +)) / Double(ratings.count)
            return (angle, assets, avg)
        }.sorted { $0.avgRating > $1.avgRating }
    }

    var body: some View {
        NavigationView {
            ZStack(alignment: .leading) {
                VStack(spacing: 0) {
                    // Header bar
                    HStack {
                        Button(action: { withAnimation { isSidebarOpen.toggle() } }) {
                            Image(systemName: "sidebar.left")
                                .font(.system(size: 22))
                                .foregroundColor(AppColors.primary)
                        }
                        .buttonStyle(CustomIconButtonStyle(size: 40, backgroundColor: .clear))

                        Spacer()

                        // Current section name (centered header)
                        VStack(spacing: 2) {
                            Text(currentSectionTitle)
                                .font(AppFonts.headline)
                                .foregroundColor(AppColors.textPrimary)

                            // Breadcrumb for tooth selection
                            if selectedTooth != nil, let proc = selectedProcedure {
                                HStack(spacing: 4) {
                                    Text(proc)
                                        .font(AppFonts.caption2)
                                        .foregroundColor(AppColors.textSecondary)
                                    Image(systemName: "chevron.right")
                                        .font(.system(size: 8))
                                        .foregroundColor(AppColors.textSecondary)
                                    Text("Tooth \(selectedTooth!.toothNumber)")
                                        .font(AppFonts.caption2)
                                        .foregroundColor(AppColors.textSecondary)
                                }
                            }
                        }

                        Spacer()

                        // Filter/sort button (placeholder for future functionality)
                        Button(action: { }) {
                            Image(systemName: "line.3.horizontal.decrease.circle")
                                .font(.system(size: 22))
                                .foregroundColor(AppColors.primary)
                        }
                        .buttonStyle(CustomIconButtonStyle(size: 40, backgroundColor: .clear))
                    }
                    .padding(16)
                    .background(AppColors.background)
                    .zIndex(20)

                    // Main content
                    ScrollView {
                        if selectedTooth != nil {
                            // Show grouped by stage and angle - always show both sections
                            VStack(alignment: .leading, spacing: 20) {
                                ForEach(["Preparation", "Restoration"], id: \.self) { stage in
                                    let angleGroups = assetsByAngle(for: stage)
                                    StageSection(
                                        stage: stage,
                                        angleGroups: angleGroups,
                                        expandedAngle: $expandedAngleStack,
                                        metadataManager: metadataManager,
                                        isCollapsed: collapsedStages.contains(stage),
                                        onToggleCollapse: {
                                            withAnimation(.easeInOut(duration: 0.2)) {
                                                if collapsedStages.contains(stage) {
                                                    collapsedStages.remove(stage)
                                                } else {
                                                    collapsedStages.insert(stage)
                                                }
                                            }
                                        },
                                        highlightedPhotoId: highlightedPhotoId,
                                        showPhotoHighlight: showPhotoHighlight
                                    )
                                }
                            }
                            .padding(16)
                        } else if filteredAssets.isEmpty {
                            VStack(spacing: 20) {
                                Image(systemName: "folder")
                                    .font(.system(size: 50))
                                    .foregroundColor(AppColors.textSecondary)
                                Text("Select a procedure")
                                    .font(AppFonts.subheadline)
                                    .foregroundColor(AppColors.textSecondary)
                            }
                            .frame(maxWidth: .infinity)
                            .padding(.horizontal, 16)
                            .padding(.top, 100)
                        } else {
                            // Show flat grid for procedure-level view
                            LazyVGrid(columns: columns, spacing: 15) {
                                ForEach(filteredAssets, id: \.localIdentifier) { asset in
                                    let isHighlighted = showPhotoHighlight && asset.localIdentifier == highlightedPhotoId
                                    NavigationLink(destination: PhotoDetailView(asset: asset)) {
                                        AssetThumbnail(asset: asset)
                                            .frame(height: 120)
                                            .clipped()
                                            .cornerRadius(8)
                                            .overlay(
                                                RoundedRectangle(cornerRadius: 8)
                                                    .stroke(Color.blue, lineWidth: isHighlighted ? 3 : 0)
                                            )
                                            .shadow(color: .blue.opacity(isHighlighted ? 0.8 : 0), radius: 12)
                                            .shadow(color: .blue.opacity(isHighlighted ? 0.5 : 0), radius: 20)
                                            .scaleEffect(isHighlighted ? 1.05 : 1.0)
                                            .animation(.easeInOut(duration: 0.3), value: isHighlighted)
                                    }
                                }
                            }
                            .padding(16)
                        }
                    }
                }
                .offset(x: isSidebarOpen ? 250 : 0)

                // Edge swipe gesture overlay (left edge for opening, below header)
                if !isSidebarOpen {
                    VStack(spacing: 0) {
                        // Spacer for header height (approx 60pt)
                        Color.clear.frame(height: 60)

                        HStack {
                            Color.clear
                                .frame(width: 60)
                                .contentShape(Rectangle())
                                .highPriorityGesture(
                                    DragGesture(minimumDistance: 5, coordinateSpace: .local)
                                        .onChanged { value in
                                            dragOffset = value.translation.width
                                        }
                                        .onEnded { value in
                                            // Open sidebar if swiped right with enough distance
                                            if value.translation.width > 20 {
                                                withAnimation(.easeOut(duration: 0.25)) { isSidebarOpen = true }
                                            }
                                            dragOffset = 0
                                        }
                                )
                            Spacer()
                        }
                    }
                }

                // Sidebar
                if isSidebarOpen {
                    HStack(spacing: 0) {
                        VStack(alignment: .leading, spacing: 0) {
                            Text("Procedures")
                                .font(AppFonts.title3)
                                .foregroundColor(AppColors.textPrimary)
                                .padding(.top, 50)
                                .padding(.horizontal)

                            // All Photos button
                            Button(action: {
                                selectedProcedure = nil
                                selectedTooth = nil
                                withAnimation { isSidebarOpen = false }
                            }) {
                                HStack {
                                    Image(systemName: "square.grid.2x2")
                                    Text("All Photos")
                                        .font(AppFonts.subheadline)
                                    Spacer()
                                }
                                .padding()
                                .foregroundColor(selectedProcedure == nil ? AppColors.primary : AppColors.textPrimary)
                                .background(selectedProcedure == nil ? AppColors.textPrimary.opacity(0.1) : Color.clear)
                            }

                            Divider().background(AppColors.secondary)

                            // Procedure folders with tooth subfolders
                            ScrollView {
                                VStack(alignment: .leading, spacing: 0) {
                                    ForEach(metadataManager.procedures, id: \.self) { procedure in
                                        ProcedureFolderView(
                                            procedure: procedure,
                                            toothEntries: metadataManager.getToothEntries(for: procedure),
                                            selectedProcedure: $selectedProcedure,
                                            selectedTooth: $selectedTooth,
                                            isSidebarOpen: $isSidebarOpen,
                                            metadataManager: metadataManager,
                                            assets: library.assets,
                                            onRename: { folder in
                                                folderToRename = folder
                                                renameFolderText = folder
                                                showRenameSheet = true
                                            },
                                            onDelete: { folder in
                                                folderToDelete = folder
                                                showDeleteConfirmation = true
                                            },
                                            onColorEdit: { folder in
                                                folderForColorEdit = folder
                                                showColorPicker = true
                                            }
                                        )
                                    }
                                }
                            }

                            Divider().background(AppColors.secondary)

                            // Add Folder button
                            Button(action: {
                                newFolderName = ""
                                showAddFolderSheet = true
                            }) {
                                HStack {
                                    Image(systemName: "folder.badge.plus")
                                        .foregroundColor(AppColors.success)
                                    Text("Add Folder")
                                        .font(AppFonts.subheadline)
                                        .foregroundColor(AppColors.textPrimary)
                                    Spacer()
                                }
                                .padding()
                            }

                            Spacer()
                        }
                        .frame(width: 250)
                        .background(AppColors.surface.opacity(0.98))
                        .edgesIgnoringSafeArea(.vertical)

                        // Tap or swipe outside to close
                        Color.black.opacity(0.3)
                            .contentShape(Rectangle())
                            .onTapGesture { withAnimation(.easeOut(duration: 0.25)) { isSidebarOpen = false } }
                            .highPriorityGesture(
                                DragGesture(minimumDistance: 5, coordinateSpace: .local)
                                    .onEnded { value in
                                        // Close sidebar if swiped left
                                        if value.translation.width < -20 {
                                            withAnimation(.easeOut(duration: 0.25)) { isSidebarOpen = false }
                                        }
                                    }
                            )
                    }
                    .zIndex(2)
                    .transition(.move(edge: .leading))
                    .highPriorityGesture(
                        DragGesture(minimumDistance: 5, coordinateSpace: .global)
                            .onEnded { value in
                                // Close sidebar if swiped left anywhere
                                if value.translation.width < -20 {
                                    withAnimation(.easeOut(duration: 0.25)) { isSidebarOpen = false }
                                }
                            }
                    )
                }
            }
            .navigationBarHidden(true)
            .onAppear {
                library.fetchAssets()
                // Apply navigation from camera via shared state
                if galleryNavState.navigatedFromCamera {
                    if let proc = galleryNavState.pendingProcedure {
                        selectedProcedure = proc
                        if let toothNum = galleryNavState.pendingToothNumber,
                           let toothDate = galleryNavState.pendingToothDate {
                            // Find matching tooth entry
                            let entries = metadataManager.getToothEntries(for: proc)
                            selectedTooth = entries.first { entry in
                                entry.toothNumber == toothNum &&
                                Calendar.current.isDate(entry.date, inSameDayAs: toothDate)
                            }
                        }
                    }
                    // Trigger photo highlight animation
                    if let photoId = galleryNavState.pendingHighlightPhotoId {
                        highlightedPhotoId = photoId
                        showPhotoHighlight = true

                        // Auto-expand the angle group containing the highlighted photo
                        if let metadata = metadataManager.getMetadata(for: photoId),
                           let stage = metadata.stage,
                           let angle = metadata.angle {
                            expandedAngleStack = "\(stage)-\(angle)"
                        }

                        // Remove highlight after 1 second
                        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                            withAnimation(.easeOut(duration: 0.3)) {
                                showPhotoHighlight = false
                            }
                        }
                    }
                    // Clear navigation state after applying
                    galleryNavState.clearNavigation()
                }
            }
            // Add Folder Sheet
            .sheet(isPresented: $showAddFolderSheet) {
                NavigationView {
                    Form {
                        TextField("Folder Name", text: $newFolderName)
                    }
                    .navigationTitle("New Folder")
                    .navigationBarTitleDisplayMode(.inline)
                    .toolbar {
                        ToolbarItem(placement: .cancellationAction) {
                            Button("Cancel") { showAddFolderSheet = false }
                        }
                        ToolbarItem(placement: .confirmationAction) {
                            Button("Add") {
                                if !newFolderName.isEmpty {
                                    metadataManager.addProcedure(newFolderName)
                                    showAddFolderSheet = false
                                }
                            }
                            .disabled(newFolderName.isEmpty)
                        }
                    }
                }
            }
            // Rename Folder Sheet
            .sheet(isPresented: $showRenameSheet) {
                NavigationView {
                    Form {
                        TextField("Folder Name", text: $renameFolderText)
                    }
                    .navigationTitle("Rename Folder")
                    .navigationBarTitleDisplayMode(.inline)
                    .toolbar {
                        ToolbarItem(placement: .cancellationAction) {
                            Button("Cancel") { showRenameSheet = false }
                        }
                        ToolbarItem(placement: .confirmationAction) {
                            Button("Rename") {
                                if let oldName = folderToRename, !renameFolderText.isEmpty {
                                    metadataManager.renameProcedure(oldName, to: renameFolderText)
                                    showRenameSheet = false
                                }
                            }
                            .disabled(renameFolderText.isEmpty)
                        }
                    }
                }
            }
            // Color Picker Sheet
            .sheet(isPresented: $showColorPicker) {
                FolderColorPickerView(
                    folder: folderForColorEdit ?? "",
                    metadataManager: metadataManager,
                    isPresented: $showColorPicker
                )
            }
            // Delete Confirmation Alert
            .alert("Delete Folder", isPresented: $showDeleteConfirmation) {
                Button("Cancel", role: .cancel) { }
                Button("Delete", role: .destructive) {
                    if let folder = folderToDelete {
                        let photoCount = metadataManager.photoCount(for: folder)
                        if photoCount > 0 {
                            metadataManager.movePhotosToUnsorted(from: folder)
                        }
                        metadataManager.deleteProcedure(folder)
                        if selectedProcedure == folder {
                            selectedProcedure = nil
                            selectedTooth = nil
                        }
                    }
                }
            } message: {
                if let folder = folderToDelete {
                    let photoCount = metadataManager.photoCount(for: folder)
                    if photoCount > 0 {
                        Text("Images in this folder will be moved to \"Unsorted Photos\".")
                    } else {
                        Text("Are you sure you want to delete \"\(folder)\"?")
                    }
                }
            }
        }
    }
}

// MARK: - Folder Color Picker View
struct FolderColorPickerView: View {
    let folder: String
    @ObservedObject var metadataManager: MetadataManager
    @Binding var isPresented: Bool
    @State private var selectedColor: Color = .blue

    let colorOptions: [(name: String, color: Color)] = [
        ("Blue", .blue),
        ("Green", .green),
        ("Orange", .orange),
        ("Purple", .purple),
        ("Red", .red),
        ("Pink", .pink),
        ("Yellow", .yellow),
        ("Teal", .teal),
        ("Gray", .gray),
        ("Indigo", .indigo)
    ]

    var body: some View {
        NavigationView {
            List {
                ForEach(colorOptions, id: \.name) { option in
                    Button(action: {
                        selectedColor = option.color
                    }) {
                        HStack {
                            Circle()
                                .fill(option.color)
                                .frame(width: 24, height: 24)
                            Text(option.name)
                                .foregroundColor(.primary)
                            Spacer()
                            if selectedColor == option.color {
                                Image(systemName: "checkmark")
                                    .foregroundColor(.blue)
                            }
                        }
                    }
                }
            }
            .navigationTitle("Folder Color")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { isPresented = false }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        metadataManager.setFolderColor(selectedColor, for: folder)
                        isPresented = false
                    }
                }
            }
            .onAppear {
                selectedColor = metadataManager.getFolderColor(for: folder)
            }
        }
    }
}

// MARK: - Procedure Folder View (with expandable tooth subfolders)
struct ProcedureFolderView: View {
    let procedure: String
    let toothEntries: [ToothEntry]
    @Binding var selectedProcedure: String?
    @Binding var selectedTooth: ToothEntry?
    @Binding var isSidebarOpen: Bool
    @ObservedObject var metadataManager: MetadataManager
    let assets: [PHAsset]
    var onRename: ((String) -> Void)? = nil
    var onDelete: ((String) -> Void)? = nil
    var onColorEdit: ((String) -> Void)? = nil
    @State private var isExpanded = false

    var photoCount: Int {
        assets.filter { metadataManager.getMetadata(for: $0.localIdentifier)?.procedure == procedure }.count
    }

    var canManage: Bool {
        metadataManager.canDeleteProcedure(procedure)
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Procedure row
            Button(action: {
                if toothEntries.isEmpty {
                    selectedProcedure = procedure
                    selectedTooth = nil
                    withAnimation { isSidebarOpen = false }
                } else {
                    withAnimation { isExpanded.toggle() }
                }
            }) {
                HStack {
                    Image(systemName: isExpanded ? "folder.fill" : "folder")
                        .foregroundColor(metadataManager.getFolderColor(for: procedure))
                    Text(procedure)
                        .font(AppFonts.subheadline)
                        .foregroundColor(selectedProcedure == procedure ? AppColors.primary : AppColors.textPrimary)
                    Spacer()
                    Text("\(photoCount)")
                        .font(AppFonts.caption)
                        .foregroundColor(AppColors.textSecondary)
                    if !toothEntries.isEmpty {
                        Image(systemName: isExpanded ? "chevron.down" : "chevron.right")
                            .font(AppFonts.caption)
                            .foregroundColor(AppColors.textSecondary)
                    }
                }
                .padding(.horizontal)
                .padding(.vertical, 10)
                .background(selectedProcedure == procedure && selectedTooth == nil ? AppColors.textPrimary.opacity(0.1) : Color.clear)
            }
            .contextMenu {
                // Color option available for all folders
                Button(action: { onColorEdit?(procedure) }) {
                    Label("Change Color", systemImage: "paintpalette")
                }

                // Rename and Delete only for custom folders
                if canManage {
                    Button(action: { onRename?(procedure) }) {
                        Label("Rename", systemImage: "pencil")
                    }

                    Button(role: .destructive, action: { onDelete?(procedure) }) {
                        Label("Delete", systemImage: "trash")
                    }
                }
            }

            // Tooth subfolders (when expanded)
            if isExpanded {
                VStack(alignment: .leading, spacing: 0) {
                    // View all for this procedure
                    Button(action: {
                        selectedProcedure = procedure
                        selectedTooth = nil
                        withAnimation { isSidebarOpen = false }
                    }) {
                        HStack {
                            Image(systemName: "photo.on.rectangle.angled")
                                .foregroundColor(AppColors.textSecondary)
                            Text("All \(procedure)")
                                .font(AppFonts.caption)
                                .foregroundColor(selectedProcedure == procedure && selectedTooth == nil ? AppColors.primary : AppColors.textPrimary)
                            Spacer()
                        }
                        .padding(.leading, 40)
                        .padding(.vertical, 6)
                    }

                    ForEach(toothEntries) { entry in
                        ToothSubfolderRow(
                            entry: entry,
                            selectedTooth: $selectedTooth,
                            selectedProcedure: $selectedProcedure,
                            isSidebarOpen: $isSidebarOpen,
                            metadataManager: metadataManager,
                            assets: assets
                        )
                    }
                }
                .transition(.opacity)
            }
        }
    }
}

// MARK: - Tooth Subfolder Row
struct ToothSubfolderRow: View {
    let entry: ToothEntry
    @Binding var selectedTooth: ToothEntry?
    @Binding var selectedProcedure: String?
    @Binding var isSidebarOpen: Bool
    @ObservedObject var metadataManager: MetadataManager
    let assets: [PHAsset]

    var photoCount: Int {
        assets.filter { asset in
            guard let meta = metadataManager.getMetadata(for: asset.localIdentifier) else { return false }
            return meta.procedure == entry.procedure &&
                   meta.toothNumber == entry.toothNumber &&
                   meta.toothDate != nil &&
                   Calendar.current.isDate(meta.toothDate!, inSameDayAs: entry.date)
        }.count
    }

    var isSelected: Bool {
        guard let sel = selectedTooth else { return false }
        return sel.procedure == entry.procedure &&
               sel.toothNumber == entry.toothNumber &&
               Calendar.current.isDate(sel.date, inSameDayAs: entry.date)
    }

    var body: some View {
        Button(action: {
            selectedProcedure = entry.procedure
            selectedTooth = entry
            withAnimation { isSidebarOpen = false }
        }) {
            HStack {
                Image(systemName: "tooth")
                    .font(AppFonts.caption)
                    .foregroundColor(AppColors.success)
                Text("#\(entry.toothNumber)")
                    .font(AppFonts.geistSemiBold(12))
                    .foregroundColor(isSelected ? AppColors.primary : AppColors.textPrimary)
                Text(entry.dateString)
                    .font(AppFonts.caption2)
                    .foregroundColor(AppColors.textSecondary)
                Spacer()
                Text("\(photoCount)")
                    .font(AppFonts.caption2)
                    .foregroundColor(AppColors.textSecondary)
            }
            .padding(.leading, 40)
            .padding(.vertical, 6)
            .background(isSelected ? AppColors.textPrimary.opacity(0.1) : Color.clear)
        }
    }
}

// MARK: - Stage Section (Preparation/Restoration)
struct StageSection: View {
    let stage: String
    let angleGroups: [(angle: String, assets: [PHAsset], avgRating: Double)]
    @Binding var expandedAngle: String?
    @ObservedObject var metadataManager: MetadataManager
    var isCollapsed: Bool = false
    var onToggleCollapse: (() -> Void)? = nil
    var highlightedPhotoId: String? = nil
    var showPhotoHighlight: Bool = false

    let columns = [GridItem(.flexible()), GridItem(.flexible()), GridItem(.flexible())]

    var photoCount: Int {
        angleGroups.flatMap { $0.assets }.count
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Stage header with collapse button
            Button(action: { onToggleCollapse?() }) {
                HStack {
                    Image(systemName: stage == "Preparation" ? "wrench.and.screwdriver" : "checkmark.seal")
                        .foregroundColor(stage == "Preparation" ? AppColors.warning : AppColors.success)
                    Text(stage)
                        .font(AppFonts.headline)
                        .foregroundColor(AppColors.textPrimary)
                    Spacer()
                    Text("\(photoCount) photos")
                        .font(AppFonts.caption)
                        .foregroundColor(AppColors.textSecondary)

                    // Collapse/expand arrow button
                    Image(systemName: isCollapsed ? "chevron.down" : "chevron.up")
                        .font(AppFonts.caption)
                        .foregroundColor(AppColors.textSecondary)
                        .padding(.leading, 8)
                }
                .padding(.vertical, 10)
                .padding(.horizontal, 16)
                .background(AppColors.secondary.opacity(0.2))
                .cornerRadius(8)
            }

            // Content (collapsible)
            if !isCollapsed {
                if angleGroups.isEmpty {
                    // Empty state for this stage
                    HStack {
                        Spacer()
                        VStack(spacing: 8) {
                            Image(systemName: "photo.badge.plus")
                                .font(.system(size: 22))
                                .foregroundColor(AppColors.textSecondary.opacity(0.5))
                            Text("No \(stage.lowercased()) photos")
                                .font(AppFonts.caption)
                                .foregroundColor(AppColors.textSecondary.opacity(0.5))
                        }
                        .padding(.vertical, 20)
                        Spacer()
                    }
                    .background(AppColors.secondary.opacity(0.05))
                    .cornerRadius(8)
                } else {
                    // Angle stacks in grid
                    LazyVGrid(columns: columns, spacing: 12) {
                        ForEach(angleGroups, id: \.angle) { group in
                            AngleStackView(
                                angle: group.angle,
                                assets: group.assets,
                                avgRating: group.avgRating,
                                isExpanded: expandedAngle == "\(stage)-\(group.angle)",
                                onTap: {
                                    withAnimation {
                                        if expandedAngle == "\(stage)-\(group.angle)" {
                                            expandedAngle = nil
                                        } else {
                                            expandedAngle = "\(stage)-\(group.angle)"
                                        }
                                    }
                                },
                                metadataManager: metadataManager,
                                highlightedPhotoId: highlightedPhotoId,
                                showPhotoHighlight: showPhotoHighlight
                            )
                        }
                    }
                    .padding(.horizontal, 4)

                    // Expanded view - renders outside grid at full width
                    if let expanded = expandedAngle,
                       expanded.hasPrefix("\(stage)-"),
                       let group = angleGroups.first(where: { "\(stage)-\($0.angle)" == expanded }) {
                        ExpandedAngleView(
                            angle: group.angle,
                            assets: group.assets,
                            metadataManager: metadataManager,
                            highlightedPhotoId: highlightedPhotoId,
                            showPhotoHighlight: showPhotoHighlight
                        )
                        .transition(.opacity.combined(with: .scale(scale: 0.95)))
                    }
                }
            }
        }
    }
}

// MARK: - Angle Stack View (collated images by angle - collapsed preview only)
struct AngleStackView: View {
    let angle: String
    let assets: [PHAsset]
    let avgRating: Double
    let isExpanded: Bool
    let onTap: () -> Void
    @ObservedObject var metadataManager: MetadataManager
    var highlightedPhotoId: String? = nil
    var showPhotoHighlight: Bool = false

    // Check if this angle group contains the highlighted photo
    var containsHighlightedPhoto: Bool {
        guard showPhotoHighlight, let highlightId = highlightedPhotoId else { return false }
        return assets.contains { $0.localIdentifier == highlightId }
    }

    var body: some View {
        Button(action: onTap) {
            VStack(alignment: .leading, spacing: 4) {
                // Stacked preview (shows multiple overlapping thumbnails)
                ZStack {
                    ForEach(Array(assets.prefix(3).enumerated().reversed()), id: \.element.localIdentifier) { index, asset in
                        AssetThumbnail(asset: asset)
                            .frame(height: 80)
                            .cornerRadius(6)
                            .shadow(radius: 2)
                            .offset(x: CGFloat(index) * 4, y: CGFloat(index) * 4)
                    }
                }
                .frame(height: 90)
                .clipped()

                HStack {
                    Text(angle)
                        .font(AppFonts.geistSemiBold(11))
                        .foregroundColor(AppColors.textPrimary)
                    Spacer()
                    Text("\(assets.count)")
                        .font(AppFonts.caption2)
                        .foregroundColor(AppColors.textSecondary)
                }

                // Rating stars
                if avgRating > 0 {
                    HStack(spacing: 2) {
                        ForEach(1...5, id: \.self) { star in
                            Image(systemName: star <= Int(avgRating) ? "star.fill" : "star")
                                .font(.system(size: 8))
                                .foregroundColor(.yellow)
                        }
                    }
                }
            }
        }
        .padding(12)
        .background(isExpanded ? AppColors.primary.opacity(0.1) : AppColors.secondary.opacity(0.1))
        .cornerRadius(8)
        .overlay(
            RoundedRectangle(cornerRadius: 8)
                .stroke(Color.blue, lineWidth: containsHighlightedPhoto ? 3 : 0)
        )
        .shadow(color: .blue.opacity(containsHighlightedPhoto ? 0.8 : 0), radius: 12)
        .shadow(color: .blue.opacity(containsHighlightedPhoto ? 0.5 : 0), radius: 20)
        .scaleEffect(containsHighlightedPhoto ? 1.05 : 1.0)
        .animation(.easeInOut(duration: 0.3), value: containsHighlightedPhoto)
    }
}

// MARK: - Expanded Angle View (full-width horizontal scroll)
struct ExpandedAngleView: View {
    let angle: String
    let assets: [PHAsset]
    @ObservedObject var metadataManager: MetadataManager
    var highlightedPhotoId: String? = nil
    var showPhotoHighlight: Bool = false

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Header showing angle name
            HStack {
                Text(angle)
                    .font(AppFonts.geistSemiBold(12))
                    .foregroundColor(AppColors.textPrimary)
                Spacer()
                Text("\(assets.count) photos")
                    .font(AppFonts.caption2)
                    .foregroundColor(AppColors.textSecondary)
            }
            .padding(.horizontal, 4)

            // Horizontally scrolling photos
            GeometryReader { geometry in
                let spacing: CGFloat = 12
                let itemPadding: CGFloat = 8
                let ratingHeight: CGFloat = 20
                let itemHeight: CGFloat = 120
                let totalItemHeight = itemHeight + ratingHeight + itemPadding * 2
                let itemCount = assets.count
                let totalSpacing = spacing * CGFloat(max(0, itemCount - 1))
                let horizontalPadding: CGFloat = 16
                let availableWidth = geometry.size.width - totalSpacing - horizontalPadding * 2

                // Calculate item width: expand to fit all items, max 150pt each, min based on available space
                let idealItemWidth = availableWidth / CGFloat(max(1, itemCount))
                let itemWidth = min(max(idealItemWidth, 80), 150)

                // Determine if scrolling is needed
                let totalContentWidth = (itemWidth + itemPadding * 2) * CGFloat(itemCount) + totalSpacing
                let needsScroll = totalContentWidth > geometry.size.width - horizontalPadding * 2

                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: spacing) {
                        ForEach(assets, id: \.localIdentifier) { asset in
                            let isHighlighted = showPhotoHighlight && asset.localIdentifier == highlightedPhotoId
                            NavigationLink(destination: PhotoDetailView(asset: asset)) {
                                VStack(spacing: 6) {
                                    AssetThumbnail(asset: asset)
                                        .frame(width: itemWidth, height: itemHeight)
                                        .cornerRadius(8)

                                    // Rating display
                                    HStack(spacing: 2) {
                                        ForEach(1...5, id: \.self) { star in
                                            let currentRating = metadataManager.getRating(for: asset.localIdentifier) ?? 0
                                            Image(systemName: star <= currentRating ? "star.fill" : "star")
                                                .font(.system(size: 10))
                                                .foregroundColor(.yellow)
                                        }
                                    }
                                }
                                .padding(itemPadding)
                                .background(Color.gray.opacity(0.15))
                                .cornerRadius(10)
                                .overlay(
                                    RoundedRectangle(cornerRadius: 10)
                                        .stroke(Color.blue, lineWidth: isHighlighted ? 3 : 0)
                                )
                                .shadow(color: .blue.opacity(isHighlighted ? 0.8 : 0), radius: 12)
                                .shadow(color: .blue.opacity(isHighlighted ? 0.5 : 0), radius: 20)
                                .scaleEffect(isHighlighted ? 1.05 : 1.0)
                                .animation(.easeInOut(duration: 0.3), value: isHighlighted)
                            }
                        }
                    }
                    .padding(.horizontal, horizontalPadding)
                    .frame(minWidth: needsScroll ? nil : geometry.size.width, alignment: .center)
                }
            }
            .frame(height: 180)
        }
        .padding(12)
        .background(Color.blue.opacity(0.1))
        .cornerRadius(8)
    }
}

// MARK: - Rating View
struct RatingView: View {
    let rating: Int
    let assetID: String
    @ObservedObject var metadataManager: MetadataManager

    var body: some View {
        HStack(spacing: 4) {
            ForEach(1...5, id: \.self) { value in
                Button(action: {
                    metadataManager.setRating(value, for: assetID)
                }) {
                    Image(systemName: value <= rating ? "star.fill" : "star")
                        .font(.system(size: 16))
                        .foregroundColor(value <= rating ? .yellow : .gray.opacity(0.5))
                }
            }
        }
    }
}

struct PhotoDetailView: View {
    let asset: PHAsset
    @State private var image: UIImage?
    @State private var isEditing = false
    @ObservedObject var metadataManager = MetadataManager.shared

    var metadata: PhotoMetadata? {
        metadataManager.getMetadata(for: asset.localIdentifier)
    }

    var body: some View {
        ZStack {
            Color.black.ignoresSafeArea()
            VStack {
                if let img = image {
                    Image(uiImage: img)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                } else {
                    ProgressView()
                }

                // Metadata display
                if let meta = metadata {
                    VStack(alignment: .leading, spacing: 8) {
                        // Top row: Procedure and Tooth
                        HStack(spacing: 8) {
                            if let proc = meta.procedure {
                                Text(proc)
                                    .font(AppFonts.geistSemiBold(12))
                                    .padding(.horizontal, 8)
                                    .padding(.vertical, 4)
                                    .background(AppColors.primary.opacity(0.8))
                                    .cornerRadius(4)
                            }
                            if let tooth = meta.toothNumber {
                                HStack(spacing: 2) {
                                    Image(systemName: "tooth")
                                        .font(AppFonts.caption2)
                                    Text("#\(tooth)")
                                        .font(AppFonts.geistSemiBold(12))
                                }
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(AppColors.success.opacity(0.8))
                                .cornerRadius(4)
                            }
                            if let date = meta.toothDate {
                                let formatter = DateFormatter()
                                let _ = formatter.dateStyle = .short
                                Text(formatter.string(from: date))
                                    .font(AppFonts.caption2)
                                    .foregroundColor(AppColors.textSecondary)
                            }
                        }

                        // Second row: Stage and Angle
                        HStack(spacing: 8) {
                            if let stage = meta.stage {
                                HStack(spacing: 4) {
                                    Image(systemName: stage == "Preparation" ? "wrench.and.screwdriver" : "checkmark.seal")
                                        .font(AppFonts.caption2)
                                    Text(stage)
                                        .font(AppFonts.caption)
                                }
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(stage == "Preparation" ? AppColors.warning.opacity(0.8) : AppColors.success.opacity(0.8))
                                .cornerRadius(4)
                            }
                            if let angle = meta.angle {
                                Text(angle)
                                    .font(AppFonts.caption)
                                    .padding(.horizontal, 8)
                                    .padding(.vertical, 4)
                                    .background(Color.purple.opacity(0.8))
                                    .cornerRadius(4)
                            }
                        }

                        // Rating row
                        HStack {
                            Text("Rating:")
                                .font(AppFonts.caption)
                                .foregroundColor(AppColors.textSecondary)
                            RatingView(
                                rating: meta.rating ?? 0,
                                assetID: asset.localIdentifier,
                                metadataManager: metadataManager
                            )
                        }
                    }
                    .padding()
                    .background(AppColors.surface.opacity(0.9))
                    .cornerRadius(10)
                    .padding()
                }
            }
        }
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button("Edit") { isEditing = true }
            }
        }
        .fullScreenCover(isPresented: $isEditing) {
            if let img = image { PhotoEditorView(inputImage: img) }
        }
        .onAppear {
            PhotoLibraryManager.shared.requestImage(for: asset) { loadedImg in
                self.image = loadedImg
            }
        }
    }
}

// MARK: - 4. ADVANCED PHOTO EDITOR
struct PhotoEditorView: View {
    let inputImage: UIImage
    @State private var displayedImage: UIImage?
    @State private var baseImage: UIImage?
    @Environment(\.presentationMode) var presentationMode
    @State private var selectedTab = 0
    @State private var brightness = 0.0
    @State private var contrast = 1.0
    @State private var saturation = 1.0
    @State private var sharpness = 0.0

    // Crop mode state
    @State private var isCropping = false
    @State private var cropRotation = 0.0  // Fine rotation in degrees (-45 to 45)
    @State private var cropRect: CGRect = .zero
    @State private var cropScale: CGFloat = 1.0
    @State private var cropOffset: CGSize = .zero
    // For smooth gesture handling
    @State private var lastCropScale: CGFloat = 1.0
    @State private var lastCropOffset: CGSize = .zero
    // Adjustable crop frame dimensions
    @State private var cropFrameWidth: CGFloat = 0
    @State private var cropFrameHeight: CGFloat = 0
    @State private var initialCropFrameWidth: CGFloat = 0
    @State private var initialCropFrameHeight: CGFloat = 0

    private let context = CIContext()

    var body: some View {
        NavigationView {
            VStack {
                Spacer()
                if isCropping {
                    // Crop mode view
                    GeometryReader { geo in
                        if let img = displayedImage {
                            ZStack {
                                // Darkened background
                                Color.black.opacity(0.7)

                                // Rotated image
                                Image(uiImage: img)
                                    .resizable()
                                    .aspectRatio(contentMode: .fit)
                                    .rotationEffect(.degrees(cropRotation))
                                    .scaleEffect(cropScale)
                                    .offset(cropOffset)
                                    .gesture(
                                        MagnificationGesture()
                                            .onChanged { value in
                                                // Apply relative scale change from last scale
                                                let newScale = lastCropScale * value
                                                cropScale = max(0.5, min(3.0, newScale))
                                            }
                                            .onEnded { _ in
                                                // Store the final scale for next gesture
                                                lastCropScale = cropScale
                                            }
                                    )
                                    .simultaneousGesture(
                                        DragGesture()
                                            .onChanged { value in
                                                // Apply relative offset from last position
                                                cropOffset = CGSize(
                                                    width: lastCropOffset.width + value.translation.width,
                                                    height: lastCropOffset.height + value.translation.height
                                                )
                                            }
                                            .onEnded { _ in
                                                // Store the final offset for next gesture
                                                lastCropOffset = cropOffset
                                            }
                                    )

                                // Crop frame overlay
                                CropOverlayView(
                                    size: geo.size,
                                    cropWidth: $cropFrameWidth,
                                    cropHeight: $cropFrameHeight,
                                    imageAspectRatio: img.size.width / img.size.height
                                )
                            }
                        }
                    }
                    .padding()
                } else {
                    // Normal view
                    if let img = displayedImage {
                        Image(uiImage: img)
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .padding()
                    } else {
                        ProgressView()
                    }
                }
                Spacer()

                VStack(spacing: 20) {
                    if isCropping {
                        // Crop controls with fine rotation
                        VStack(spacing: 16) {
                            HStack(spacing: 30) {
                                Button(action: { cropScale = 1.0; cropOffset = .zero; cropRotation = 0; lastCropScale = 1.0; lastCropOffset = .zero }) {
                                    VStack {
                                        Image(systemName: "arrow.counterclockwise").font(.system(size: 22))
                                        Text("Reset").font(AppFonts.caption)
                                    }
                                }
                                Button(action: { applyCrop() }) {
                                    VStack {
                                        Image(systemName: "checkmark.circle.fill").font(.system(size: 22))
                                        Text("Apply").font(AppFonts.caption)
                                    }
                                }
                                .foregroundColor(AppColors.success)
                                Button(action: { cancelCrop() }) {
                                    VStack {
                                        Image(systemName: "xmark.circle").font(.system(size: 22))
                                        Text("Cancel").font(AppFonts.caption)
                                    }
                                }
                                .foregroundColor(AppColors.error)
                            }
                            .foregroundColor(AppColors.textPrimary)

                            // Fine rotation slider (only in crop mode)
                            VStack(spacing: 8) {
                                Text("Rotation")
                                    .font(AppFonts.caption)
                                    .foregroundColor(AppColors.textSecondary)
                                HStack {
                                    Image(systemName: "rotate.left")
                                        .foregroundColor(AppColors.textSecondary)
                                    Slider(value: $cropRotation, in: -45...45, step: 0.5)
                                        .accentColor(AppColors.primary)
                                    Image(systemName: "rotate.right")
                                        .foregroundColor(AppColors.textSecondary)
                                }
                                Text("\(String(format: "%.1f", cropRotation))°")
                                    .font(AppFonts.caption)
                                    .foregroundColor(AppColors.textPrimary)
                            }
                            .padding(.horizontal)
                        }
                        .padding()
                    } else if selectedTab == 0 {
                        // Transform tab
                        VStack(spacing: 16) {
                            HStack(spacing: 30) {
                                Button(action: { rotateImage() }) {
                                    VStack {
                                        Image(systemName: "rotate.right").font(.system(size: 22))
                                        Text("90°").font(AppFonts.caption)
                                    }
                                }
                                Button(action: { startCropping() }) {
                                    VStack {
                                        Image(systemName: "crop").font(.system(size: 22))
                                        Text("Crop").font(AppFonts.caption)
                                    }
                                }
                            }
                            .foregroundColor(AppColors.textPrimary)
                        }
                        .padding()
                    } else {
                        // Adjust tab
                        VStack(spacing: 15) {
                            AdjustmentRow(icon: "sun.max", label: "Bright", value: $brightness, range: -2.0...2.0)
                            AdjustmentRow(icon: "circle.righthalf.filled", label: "Contrast", value: $contrast, range: 0.625...1.375)
                            AdjustmentRow(icon: "drop.fill", label: "Sat", value: $saturation, range: 0.25...1.75)
                            AdjustmentRow(icon: "triangle", label: "Sharp", value: $sharpness, range: 0.0...7.5)
                        }
                        .padding(.horizontal)
                    }

                    if !isCropping {
                        Divider().background(AppColors.secondary)
                        HStack {
                            Button(action: { selectedTab = 0 }) {
                                VStack {
                                    Image(systemName: "crop.rotate")
                                    Text("Transform").font(AppFonts.caption2)
                                }
                            }
                            .frame(maxWidth: .infinity)
                            .foregroundColor(selectedTab == 0 ? AppColors.primary : AppColors.textSecondary)

                            Button(action: { selectedTab = 1 }) {
                                VStack {
                                    Image(systemName: "slider.horizontal.3")
                                    Text("Adjust").font(AppFonts.caption2)
                                }
                            }
                            .frame(maxWidth: .infinity)
                            .foregroundColor(selectedTab == 1 ? AppColors.primary : AppColors.textSecondary)
                        }
                        .padding(.top, 10)
                    }
                }
                .padding(.bottom)
                .background(AppColors.surface)
            }
            .navigationTitle(isCropping ? "Crop & Rotate" : "Edit")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    if !isCropping {
                        Button("Cancel") { presentationMode.wrappedValue.dismiss() }
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    if !isCropping {
                        Button("Save") { saveImage() }
                    }
                }
            }
            .onAppear {
                baseImage = inputImage
                displayedImage = inputImage
                applyProcessing()
            }
            .onChange(of: brightness) { applyProcessing() }
            .onChange(of: contrast) { applyProcessing() }
            .onChange(of: saturation) { applyProcessing() }
            .onChange(of: sharpness) { applyProcessing() }
        }
    }

    func startCropping() {
        cropRotation = 0
        cropScale = 1.0
        cropOffset = .zero
        lastCropScale = 1.0
        lastCropOffset = .zero
        cropFrameWidth = 0
        cropFrameHeight = 0
        withAnimation { isCropping = true }
    }

    func cancelCrop() {
        withAnimation { isCropping = false }
        cropRotation = 0
        cropScale = 1.0
        cropOffset = .zero
        lastCropScale = 1.0
        lastCropOffset = .zero
        cropFrameWidth = 0
        cropFrameHeight = 0
    }

    func applyCrop() {
        guard let img = baseImage else { return }

        // Apply rotation first
        var processedImage = img
        if cropRotation != 0 {
            if let rotated = img.rotated(by: Measurement(value: cropRotation, unit: .degrees)) {
                processedImage = rotated
            }
        }

        // Apply scale crop (center crop based on scale)
        if cropScale != 1.0 {
            let scaleFactor = 1.0 / cropScale
            let newWidth = processedImage.size.width * scaleFactor
            let newHeight = processedImage.size.height * scaleFactor
            let xOffset = (processedImage.size.width - newWidth) / 2.0
            let yOffset = (processedImage.size.height - newHeight) / 2.0
            let cropRect = CGRect(x: xOffset, y: yOffset, width: newWidth, height: newHeight)

            if let cgImage = processedImage.cgImage?.cropping(to: cropRect) {
                processedImage = UIImage(cgImage: cgImage, scale: processedImage.scale, orientation: processedImage.imageOrientation)
            }
        }

        baseImage = processedImage
        applyProcessing()
        withAnimation { isCropping = false }
        cropRotation = 0
        cropScale = 1.0
        cropOffset = .zero
        lastCropScale = 1.0
        lastCropOffset = .zero
        cropFrameWidth = 0
        cropFrameHeight = 0
    }

    func applyProcessing() {
        guard let currentDisplay = baseImage else { return }
        let beginImage = CIImage(image: currentDisplay)
        let exposureFilter = CIFilter.exposureAdjust()
        exposureFilter.inputImage = beginImage
        exposureFilter.ev = Float(brightness)
        guard let exposureOutput = exposureFilter.outputImage else { return }

        let colorFilter = CIFilter.colorControls()
        colorFilter.inputImage = exposureOutput
        colorFilter.brightness = 0
        colorFilter.contrast = Float(contrast)
        colorFilter.saturation = Float(saturation)
        guard let colorOutput = colorFilter.outputImage else { return }

        let sharpFilter = CIFilter.sharpenLuminance()
        sharpFilter.inputImage = colorOutput
        sharpFilter.sharpness = Float(sharpness)
        guard let finalOutput = sharpFilter.outputImage else { return }

        if let cgimg = context.createCGImage(finalOutput, from: finalOutput.extent) {
            let processed = UIImage(cgImage: cgimg, scale: currentDisplay.scale, orientation: currentDisplay.imageOrientation)
            displayedImage = processed
        }
    }

    func rotateImage() {
        guard let img = baseImage else { return }
        baseImage = img.rotated(by: Measurement(value: -90, unit: .degrees))
        applyProcessing()
    }

    func saveImage() {
        guard let baseImg = baseImage else {
            presentationMode.wrappedValue.dismiss()
            return
        }

        // Apply the processing filters
        var finalImage = baseImg
        if let ciImage = CIImage(image: finalImage) {
            let exposureFilter = CIFilter.exposureAdjust()
            exposureFilter.inputImage = ciImage
            exposureFilter.ev = Float(brightness)

            if let exposureOutput = exposureFilter.outputImage {
                let colorFilter = CIFilter.colorControls()
                colorFilter.inputImage = exposureOutput
                colorFilter.brightness = 0
                colorFilter.contrast = Float(contrast)
                colorFilter.saturation = Float(saturation)

                if let colorOutput = colorFilter.outputImage {
                    let sharpFilter = CIFilter.sharpenLuminance()
                    sharpFilter.inputImage = colorOutput
                    sharpFilter.sharpness = Float(sharpness)

                    if let finalOutput = sharpFilter.outputImage,
                       let cgimg = context.createCGImage(finalOutput, from: finalOutput.extent) {
                        finalImage = UIImage(cgImage: cgimg, scale: finalImage.scale, orientation: finalImage.imageOrientation)
                    }
                }
            }
        }

        PhotoLibraryManager.shared.save(image: finalImage, procedure: nil, otherTags: [])
        presentationMode.wrappedValue.dismiss()
    }
}

// MARK: - Crop Overlay View
struct CropOverlayView: View {
    let size: CGSize
    @Binding var cropWidth: CGFloat
    @Binding var cropHeight: CGFloat
    let imageAspectRatio: CGFloat

    // Minimum crop dimensions
    private let minCropSize: CGFloat = 80

    var body: some View {
        let maxWidth = size.width * 0.9
        let maxHeight = size.height * 0.9

        // Initialize dimensions on first render if not set
        let displayWidth = cropWidth > 0 ? cropWidth : calculateInitialWidth(maxWidth: maxWidth, maxHeight: maxHeight)
        let displayHeight = cropHeight > 0 ? cropHeight : calculateInitialHeight(maxWidth: maxWidth, maxHeight: maxHeight)

        ZStack {
            // Transparent center (crop area)
            Rectangle()
                .fill(Color.clear)
                .frame(width: displayWidth, height: displayHeight)
                .overlay(
                    Rectangle()
                        .stroke(Color.white, lineWidth: 2)
                )
                .overlay(
                    // Grid lines - vertical
                    VStack {
                        ForEach(0..<4) { i in
                            if i > 0 {
                                Divider()
                                    .background(Color.white.opacity(0.5))
                            }
                            Spacer()
                        }
                    }
                )
                .overlay(
                    // Grid lines - horizontal
                    HStack {
                        ForEach(0..<4) { i in
                            if i > 0 {
                                Divider()
                                    .background(Color.white.opacity(0.5))
                            }
                            Spacer()
                        }
                    }
                )

            // Corner handles with drag gestures
            VStack {
                HStack {
                    // Top-left handle
                    CropCornerHandle()
                        .gesture(
                            DragGesture()
                                .onChanged { value in
                                    let deltaX = -value.translation.width
                                    let deltaY = -value.translation.height
                                    let newWidth = max(minCropSize, min(maxWidth, displayWidth + deltaX))
                                    let newHeight = max(minCropSize, min(maxHeight, displayHeight + deltaY))
                                    cropWidth = newWidth
                                    cropHeight = newHeight
                                }
                        )
                    Spacer()
                    // Top-right handle
                    CropCornerHandle()
                        .gesture(
                            DragGesture()
                                .onChanged { value in
                                    let deltaX = value.translation.width
                                    let deltaY = -value.translation.height
                                    let newWidth = max(minCropSize, min(maxWidth, displayWidth + deltaX))
                                    let newHeight = max(minCropSize, min(maxHeight, displayHeight + deltaY))
                                    cropWidth = newWidth
                                    cropHeight = newHeight
                                }
                        )
                }
                Spacer()
                HStack {
                    // Bottom-left handle
                    CropCornerHandle()
                        .gesture(
                            DragGesture()
                                .onChanged { value in
                                    let deltaX = -value.translation.width
                                    let deltaY = value.translation.height
                                    let newWidth = max(minCropSize, min(maxWidth, displayWidth + deltaX))
                                    let newHeight = max(minCropSize, min(maxHeight, displayHeight + deltaY))
                                    cropWidth = newWidth
                                    cropHeight = newHeight
                                }
                        )
                    Spacer()
                    // Bottom-right handle
                    CropCornerHandle()
                        .gesture(
                            DragGesture()
                                .onChanged { value in
                                    let deltaX = value.translation.width
                                    let deltaY = value.translation.height
                                    let newWidth = max(minCropSize, min(maxWidth, displayWidth + deltaX))
                                    let newHeight = max(minCropSize, min(maxHeight, displayHeight + deltaY))
                                    cropWidth = newWidth
                                    cropHeight = newHeight
                                }
                        )
                }
            }
            .frame(width: displayWidth, height: displayHeight)
        }
        .onAppear {
            if cropWidth == 0 || cropHeight == 0 {
                cropWidth = calculateInitialWidth(maxWidth: maxWidth, maxHeight: maxHeight)
                cropHeight = calculateInitialHeight(maxWidth: maxWidth, maxHeight: maxHeight)
            }
        }
    }

    private func calculateInitialWidth(maxWidth: CGFloat, maxHeight: CGFloat) -> CGFloat {
        if imageAspectRatio > 1 {
            // Landscape image
            return min(maxWidth, maxHeight * imageAspectRatio)
        } else {
            // Portrait or square image
            return min(maxWidth, maxHeight * imageAspectRatio)
        }
    }

    private func calculateInitialHeight(maxWidth: CGFloat, maxHeight: CGFloat) -> CGFloat {
        if imageAspectRatio > 1 {
            // Landscape image
            return min(maxHeight, maxWidth / imageAspectRatio)
        } else {
            // Portrait or square image
            return min(maxHeight, maxWidth / imageAspectRatio)
        }
    }
}

struct CropCornerHandle: View {
    var body: some View {
        ZStack {
            // Invisible larger hit area for easier touch
            Rectangle()
                .fill(Color.clear)
                .frame(width: 44, height: 44)
            // Visible corner indicator
            Rectangle()
                .fill(Color.white)
                .frame(width: 24, height: 4)
            Rectangle()
                .fill(Color.white)
                .frame(width: 4, height: 24)
        }
        .contentShape(Rectangle())
    }
}

struct AdjustmentRow: View {
    let icon: String; let label: String; @Binding var value: Double; let range: ClosedRange<Double>
    var body: some View {
        HStack { Image(systemName: icon).frame(width: 25); Text(label).font(AppFonts.caption).frame(width: 50, alignment: .leading); Slider(value: $value, in: range) }.foregroundColor(.primary)
    }
}

extension UIImage {
    func rotated(by angle: Measurement<UnitAngle>) -> UIImage? {
        let radians = CGFloat(angle.converted(to: .radians).value)
        var newSize = CGRect(origin: CGPoint.zero, size: self.size).applying(CGAffineTransform(rotationAngle: radians)).size
        newSize.width = floor(newSize.width); newSize.height = floor(newSize.height)
        UIGraphicsBeginImageContextWithOptions(newSize, false, self.scale)
        let context = UIGraphicsGetCurrentContext()!
        context.translateBy(x: newSize.width/2, y: newSize.height/2); context.rotate(by: radians)
        self.draw(in: CGRect(x: -self.size.width/2, y: -self.size.height/2, width: self.size.width, height: self.size.height))
        let newImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext(); return newImage
    }
}

// MARK: - 5. HELPERS
struct CustomGhostPicker: View {
    @Binding var selectedImage: UIImage?
    @Environment(\.presentationMode) var presentationMode
    @StateObject private var library = PhotoLibraryManager.shared
    let columns = [GridItem(.flexible()), GridItem(.flexible()), GridItem(.flexible())]
    var body: some View {
        NavigationView {
            ScrollView {
                LazyVGrid(columns: columns, spacing: 1) {
                    ForEach(library.assets, id: \.localIdentifier) { asset in
                        Button(action: { library.requestImage(for: asset) { image in self.selectedImage = image; presentationMode.wrappedValue.dismiss() } }) { AssetThumbnail(asset: asset).frame(height: 120).clipped() }
                    }
                }
            }.navigationTitle("Select Ghost Reference").toolbar { ToolbarItem(placement: .navigationBarLeading) { Button("Cancel") { presentationMode.wrappedValue.dismiss() } } }.onAppear { library.fetchAssets() }
        }
    }
}

struct AssetThumbnail: View {
    let asset: PHAsset
    @State private var image: UIImage?
    var body: some View {
        Group { if let image = image { Image(uiImage: image).resizable().aspectRatio(contentMode: .fill) } else { Rectangle().fill(Color.gray.opacity(0.2)) } }
        .onAppear { PhotoLibraryManager.shared.requestThumbnail(for: asset) { img in self.image = img } }
    }
}

class PhotoLibraryManager: ObservableObject {
    static let shared = PhotoLibraryManager()
    @Published var assets: [PHAsset] = []
    private let albumName = "Dental Portfolio"
    
    func createAlbumIfNeeded() {
        let fetchOptions = PHFetchOptions(); fetchOptions.predicate = NSPredicate(format: "title = %@", albumName)
        let collection = PHAssetCollection.fetchAssetCollections(with: .album, subtype: .any, options: fetchOptions)
        if collection.firstObject == nil {
            PHPhotoLibrary.shared().performChanges({ PHAssetCollectionChangeRequest.creationRequestForAssetCollection(withTitle: self.albumName) }, completionHandler: nil)
        }
    }
    
    func save(image: UIImage, procedure: String?, otherTags: [String]) {
        createAlbumIfNeeded()
        var placeholder: PHObjectPlaceholder?
        PHPhotoLibrary.shared().performChanges({
            let assetRequest = PHAssetCreationRequest.creationRequestForAsset(from: image)
            placeholder = assetRequest.placeholderForCreatedAsset
            let fetchOptions = PHFetchOptions(); fetchOptions.predicate = NSPredicate(format: "title = %@", self.albumName)
            let collection = PHAssetCollection.fetchAssetCollections(with: .album, subtype: .any, options: fetchOptions)
            guard let album = collection.firstObject, let albumChangeRequest = PHAssetCollectionChangeRequest(for: album), let assetPlaceholder = placeholder else { return }
            albumChangeRequest.addAssets([assetPlaceholder] as NSArray)
        }) { success, error in
            if success, let id = placeholder?.localIdentifier {
                DispatchQueue.main.async { TagManager.shared.assign(procedure: procedure, otherTags: otherTags, to: id); self.fetchAssets() }
            }
        }
    }

    func saveWithMetadata(image: UIImage, metadata: PhotoMetadata, completion: ((String?) -> Void)? = nil) {
        createAlbumIfNeeded()
        var placeholder: PHObjectPlaceholder?
        PHPhotoLibrary.shared().performChanges({
            let assetRequest = PHAssetCreationRequest.creationRequestForAsset(from: image)
            placeholder = assetRequest.placeholderForCreatedAsset
            let fetchOptions = PHFetchOptions(); fetchOptions.predicate = NSPredicate(format: "title = %@", self.albumName)
            let collection = PHAssetCollection.fetchAssetCollections(with: .album, subtype: .any, options: fetchOptions)
            guard let album = collection.firstObject, let albumChangeRequest = PHAssetCollectionChangeRequest(for: album), let assetPlaceholder = placeholder else { return }
            albumChangeRequest.addAssets([assetPlaceholder] as NSArray)
        }) { success, error in
            if success, let id = placeholder?.localIdentifier {
                DispatchQueue.main.async {
                    MetadataManager.shared.assignMetadata(metadata, to: id)
                    self.fetchAssets()
                    completion?(id)
                }
            } else {
                DispatchQueue.main.async {
                    completion?(nil)
                }
            }
        }
    }
    
    func fetchAssets() {
        let fetchOptions = PHFetchOptions(); fetchOptions.predicate = NSPredicate(format: "title = %@", albumName)
        let collection = PHAssetCollection.fetchAssetCollections(with: .album, subtype: .any, options: fetchOptions)
        guard let album = collection.firstObject else { return }
        let assetsFetch = PHAsset.fetchAssets(in: album, options: nil)
        var newAssets: [PHAsset] = []; assetsFetch.enumerateObjects { asset, _, _ in newAssets.append(asset) }
        DispatchQueue.main.async { self.assets = newAssets.reversed() }
    }
    
    func requestThumbnail(for asset: PHAsset, completion: @escaping (UIImage?) -> Void) {
        let manager = PHImageManager.default()
        let options = PHImageRequestOptions(); options.isSynchronous = false; options.deliveryMode = .opportunistic
        manager.requestImage(for: asset, targetSize: CGSize(width: 200, height: 200), contentMode: .aspectFill, options: options) { img, _ in completion(img) }
    }
    
    func requestImage(for asset: PHAsset, completion: @escaping (UIImage?) -> Void) {
        let manager = PHImageManager.default()
        let options = PHImageRequestOptions(); options.isSynchronous = false; options.deliveryMode = .highQualityFormat
        manager.requestImage(for: asset, targetSize: PHImageManagerMaximumSize, contentMode: .aspectFit, options: options) { img, _ in completion(img) }
    }
}

// MARK: - 6. PORTFOLIOS TAB
struct PortfoliosView: View {
    @ObservedObject var metadataManager = MetadataManager.shared
    @State private var showAddPortfolioSheet = false
    @State private var selectedPortfolioId: String? = nil
    @State private var showPortfolioPicker = false
    @State private var showAddRequirementSheet = false
    @State private var showDeleteConfirmation = false

    // Get the most recently created portfolio, or the selected one
    var currentPortfolio: Portfolio? {
        if let id = selectedPortfolioId {
            return metadataManager.getPortfolio(by: id)
        }
        // Default to most recently created (last in array)
        return metadataManager.portfolios.last
    }

    var stats: (fulfilled: Int, total: Int) {
        guard let portfolio = currentPortfolio else { return (0, 0) }
        return metadataManager.getPortfolioStats(portfolio)
    }

    var completionPercentage: Double {
        guard let portfolio = currentPortfolio else { return 0 }
        return metadataManager.getPortfolioCompletionPercentage(portfolio)
    }

    var body: some View {
        ZStack {
            Color.black.ignoresSafeArea()

            VStack(spacing: 0) {
                // Custom header bar
                HStack {
                    Text("Portfolios")
                        .font(.title2).bold()
                        .foregroundColor(.white)

                    Spacer()

                    // Portfolio dropdown selector (only show if portfolios exist)
                    if !metadataManager.portfolios.isEmpty {
                        Menu {
                            ForEach(metadataManager.portfolios) { portfolio in
                                Button(action: {
                                    selectedPortfolioId = portfolio.id
                                }) {
                                    HStack {
                                        Text(portfolio.name)
                                        if portfolio.id == currentPortfolio?.id {
                                            Image(systemName: "checkmark")
                                        }
                                    }
                                }
                            }
                        } label: {
                            HStack(spacing: 6) {
                                Text(currentPortfolio?.name ?? "Select")
                                    .font(.subheadline)
                                    .foregroundColor(.white)
                                    .lineLimit(1)
                                    .fixedSize(horizontal: true, vertical: false)
                                Image(systemName: "chevron.down")
                                    .font(.caption)
                                    .foregroundColor(.gray)
                            }
                            .padding(.horizontal, 12)
                            .padding(.vertical, 8)
                            .background(Color(UIColor.systemGray5))
                            .cornerRadius(8)
                        }
                        .id(currentPortfolio?.id)  // Force redraw on portfolio change
                    }

                    // Plus button
                    Button(action: { showAddPortfolioSheet = true }) {
                        Image(systemName: "plus")
                            .font(.title3)
                            .foregroundColor(.blue)
                            .padding(8)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 60)
                .padding(.bottom, 16)

                // Main content
                if metadataManager.portfolios.isEmpty {
                    // Empty state
                    Spacer()
                    VStack(spacing: 20) {
                        Image(systemName: "folder.badge.plus")
                            .font(.system(size: 60))
                            .foregroundColor(AppColors.textSecondary)
                        Text("No Portfolios Yet")
                            .font(AppFonts.title2)
                            .foregroundColor(AppColors.textSecondary)
                        Text("Create a portfolio to track\nrequired photos for assignments")
                            .font(AppFonts.subheadline)
                            .foregroundColor(AppColors.textSecondary.opacity(0.8))
                            .multilineTextAlignment(.center)
                        Button(action: { showAddPortfolioSheet = true }) {
                            HStack {
                                Image(systemName: "plus.circle.fill")
                                Text("Create Portfolio")
                            }
                        }
                        .buttonStyle(CustomPrimaryButtonStyle())
                        .padding(.top, 10)
                    }
                    Spacer()
                } else if let portfolio = currentPortfolio {
                    // Expanded portfolio view
                    ScrollView {
                        VStack(alignment: .leading, spacing: 20) {
                            // Header stats card (animated)
                            VStack(spacing: 16) {
                                HStack {
                                    VStack(alignment: .leading) {
                                        Text("Progress")
                                            .font(.subheadline)
                                            .foregroundColor(.gray)
                                        Text(String(format: "%.0f%%", completionPercentage))
                                            .font(.system(size: 36, weight: .bold))
                                            .foregroundColor(completionPercentage >= 100 ? .green : .blue)
                                    }

                                    Spacer()

                                    // Circular progress indicator
                                    ZStack {
                                        Circle()
                                            .stroke(Color.gray.opacity(0.3), lineWidth: 8)
                                            .frame(width: 70, height: 70)
                                        Circle()
                                            .trim(from: 0, to: min(1.0, completionPercentage / 100))
                                            .stroke(
                                                completionPercentage >= 100 ? Color.green : Color.blue,
                                                style: StrokeStyle(lineWidth: 8, lineCap: .round)
                                            )
                                            .frame(width: 70, height: 70)
                                            .rotationEffect(.degrees(-90))
                                        VStack(spacing: 0) {
                                            Text("\(stats.fulfilled)")
                                                .font(.system(size: 16, weight: .bold))
                                                .foregroundColor(.white)
                                            Text("of \(stats.total)")
                                                .font(.system(size: 10))
                                                .foregroundColor(.gray)
                                        }
                                    }
                                }

                                // Progress bar
                                GeometryReader { geo in
                                    ZStack(alignment: .leading) {
                                        RoundedRectangle(cornerRadius: 6)
                                            .fill(Color.gray.opacity(0.3))
                                            .frame(height: 12)

                                        RoundedRectangle(cornerRadius: 6)
                                            .fill(completionPercentage >= 100 ? Color.green : Color.blue)
                                            .frame(width: geo.size.width * min(1.0, completionPercentage / 100), height: 12)
                                    }
                                }
                                .frame(height: 12)

                                // Date created
                                HStack {
                                    Text("Created \(portfolio.dateString)")
                                        .font(.caption)
                                        .foregroundColor(.gray)
                                    Spacer()
                                }
                            }
                            .padding()
                            .background(Color(UIColor.systemGray6).opacity(0.3))
                            .cornerRadius(12)
                            .id("stats-\(portfolio.id)")
                            .transition(.opacity)

                            // Requirements section
                            VStack(alignment: .leading, spacing: 12) {
                                // Header (stationary - no transition)
                                HStack {
                                    Text("Requirements")
                                        .font(.headline)
                                        .foregroundColor(.white)
                                    Spacer()
                                    Button(action: { showAddRequirementSheet = true }) {
                                        HStack(spacing: 4) {
                                            Image(systemName: "plus.circle.fill")
                                            Text("Add")
                                        }
                                        .font(.subheadline)
                                        .foregroundColor(.blue)
                                    }
                                }

                                // Requirements content (animated)
                                VStack(spacing: 12) {
                                    if portfolio.requirements.isEmpty {
                                        VStack(spacing: 12) {
                                            Image(systemName: "doc.text")
                                                .font(.system(size: 40))
                                                .foregroundColor(.gray)
                                            Text("No requirements yet")
                                                .font(.subheadline)
                                                .foregroundColor(.gray)
                                            Text("Add requirements to specify what photos you need")
                                                .font(.caption)
                                                .foregroundColor(.gray.opacity(0.8))
                                                .multilineTextAlignment(.center)
                                        }
                                        .frame(maxWidth: .infinity)
                                        .padding(.vertical, 30)
                                    } else {
                                        ForEach(portfolio.requirements) { requirement in
                                            RequirementStatusView(
                                                requirement: requirement,
                                                portfolioId: portfolio.id
                                            )
                                        }
                                    }
                                }
                                .id("requirements-\(portfolio.id)")
                                .transition(.opacity)
                            }

                            // Delete button (animated)
                            Button(action: { showDeleteConfirmation = true }) {
                                HStack {
                                    Image(systemName: "trash")
                                    Text("Delete Portfolio")
                                }
                                .font(.subheadline)
                                .foregroundColor(.red)
                                .frame(maxWidth: .infinity)
                                .padding()
                                .background(Color(UIColor.systemGray6).opacity(0.3))
                                .cornerRadius(10)
                            }
                            .padding(.top, 20)
                            .id("delete-\(portfolio.id)")
                            .transition(.opacity)

                            Spacer(minLength: 50)
                        }
                        .padding()
                        .animation(.easeInOut(duration: 0.2), value: portfolio.id)
                    }
                }
            }
        }
        .sheet(isPresented: $showAddPortfolioSheet) {
            AddPortfolioSheet(isPresented: $showAddPortfolioSheet)
        }
        .sheet(isPresented: $showAddRequirementSheet) {
            if let portfolio = currentPortfolio {
                AddRequirementSheet(isPresented: $showAddRequirementSheet, portfolioId: portfolio.id)
            }
        }
        .alert("Delete Portfolio", isPresented: $showDeleteConfirmation) {
            Button("Cancel", role: .cancel) { }
            Button("Delete", role: .destructive) {
                if let portfolio = currentPortfolio {
                    metadataManager.deletePortfolio(portfolio)
                    selectedPortfolioId = nil
                }
            }
        } message: {
            Text("Are you sure you want to delete \"\(currentPortfolio?.name ?? "")\"? This cannot be undone.")
        }
        .onChange(of: metadataManager.portfolios) { _ in
            // If selected portfolio was deleted, reset to most recent
            if let id = selectedPortfolioId, metadataManager.getPortfolio(by: id) == nil {
                selectedPortfolioId = nil
            }
        }
    }
}

// MARK: - Portfolio Card View
struct PortfolioCardView: View {
    let portfolio: Portfolio
    @ObservedObject var metadataManager = MetadataManager.shared

    var stats: (fulfilled: Int, total: Int) {
        metadataManager.getPortfolioStats(portfolio)
    }

    var completionPercentage: Double {
        metadataManager.getPortfolioCompletionPercentage(portfolio)
    }

    var isComplete: Bool {
        stats.fulfilled >= stats.total && stats.total > 0
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(portfolio.name)
                        .font(AppFonts.headline)
                        .foregroundColor(AppColors.textPrimary)
                    Text(portfolio.dateString)
                        .font(AppFonts.caption)
                        .foregroundColor(AppColors.textSecondary)
                }

                Spacer()

                // Status badge
                HStack(spacing: 4) {
                    Image(systemName: isComplete ? "checkmark.circle.fill" : "circle")
                        .foregroundColor(isComplete ? AppColors.success : AppColors.warning)
                    Text(isComplete ? "Complete" : "In Progress")
                        .font(AppFonts.caption)
                        .foregroundColor(isComplete ? AppColors.success : AppColors.warning)
                }
                .padding(.horizontal, 10)
                .padding(.vertical, 5)
                .background(isComplete ? AppColors.success.opacity(0.2) : AppColors.warning.opacity(0.2))
                .cornerRadius(12)
            }

            // Progress bar
            VStack(alignment: .leading, spacing: 6) {
                HStack {
                    Text("\(stats.fulfilled) / \(stats.total) photos")
                        .font(AppFonts.caption)
                        .foregroundColor(AppColors.textSecondary)
                    Spacer()
                    Text(String(format: "%.0f%%", completionPercentage))
                        .font(AppFonts.geistSemiBold(12))
                        .foregroundColor(isComplete ? AppColors.success : AppColors.primary)
                }

                GeometryReader { geo in
                    ZStack(alignment: .leading) {
                        RoundedRectangle(cornerRadius: 4)
                            .fill(AppColors.secondary.opacity(0.3))
                            .frame(height: 8)

                        RoundedRectangle(cornerRadius: 4)
                            .fill(isComplete ? AppColors.success : AppColors.primary)
                            .frame(width: geo.size.width * min(1.0, completionPercentage / 100), height: 8)
                    }
                }
                .frame(height: 8)
            }

            // Requirements summary
            if !portfolio.requirements.isEmpty {
                HStack(spacing: 8) {
                    Image(systemName: "list.bullet")
                        .font(AppFonts.caption)
                        .foregroundColor(AppColors.textSecondary)
                    Text("\(portfolio.requirements.count) requirement\(portfolio.requirements.count == 1 ? "" : "s")")
                        .font(AppFonts.caption)
                        .foregroundColor(AppColors.textSecondary)
                }
            }
        }
        .padding()
        .background(AppColors.surface.opacity(0.5))
        .cornerRadius(12)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(AppColors.secondary.opacity(0.3), lineWidth: 1)
        )
    }
}

// MARK: - Add Portfolio Sheet
struct AddPortfolioSheet: View {
    @Binding var isPresented: Bool
    @ObservedObject var metadataManager = MetadataManager.shared
    @State private var portfolioName = ""
    @State private var currentStep = 0  // 0 = name entry, 1 = add requirements
    @State private var createdPortfolioId: String? = nil

    var body: some View {
        NavigationView {
            if currentStep == 0 {
                // Step 1: Enter portfolio name
                VStack(spacing: 0) {
                    List {
                        Section(header: Text("Portfolio Name")) {
                            TextField("e.g., Fall 2024 Portfolio", text: $portfolioName)
                                .textInputAutocapitalization(.words)
                        }

                        Section {
                            Text("After naming your portfolio, you'll be prompted to add photo requirements.")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                    }
                    .listStyle(.insetGrouped)
                }
                .navigationTitle("New Portfolio")
                .navigationBarTitleDisplayMode(.inline)
                .toolbar {
                    ToolbarItem(placement: .cancellationAction) {
                        Button("Cancel") { isPresented = false }
                    }
                    ToolbarItem(placement: .confirmationAction) {
                        Button("Next") {
                            let portfolio = Portfolio(name: portfolioName)
                            metadataManager.addPortfolio(portfolio)
                            createdPortfolioId = portfolio.id
                            withAnimation { currentStep = 1 }
                        }
                        .disabled(portfolioName.isEmpty)
                    }
                }
            } else {
                // Step 2: Add requirements
                AddRequirementsStepView(
                    portfolioId: createdPortfolioId ?? "",
                    portfolioName: portfolioName,
                    isPresented: $isPresented
                )
            }
        }
    }
}

// MARK: - Add Requirements Step View
struct AddRequirementsStepView: View {
    let portfolioId: String
    let portfolioName: String
    @Binding var isPresented: Bool
    @ObservedObject var metadataManager = MetadataManager.shared
    @State private var showAddRequirementSheet = false

    var currentPortfolio: Portfolio? {
        metadataManager.getPortfolio(by: portfolioId)
    }

    var body: some View {
        ZStack {
            Color(UIColor.systemGroupedBackground).ignoresSafeArea()

            VStack(spacing: 20) {
                // Header
                VStack(spacing: 8) {
                    Image(systemName: "checkmark.circle.fill")
                        .font(.system(size: 50))
                        .foregroundColor(.green)
                    Text("Portfolio Created!")
                        .font(.title2).bold()
                    Text("\"\(portfolioName)\"")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                }
                .padding(.top, 30)

                // Requirements section
                VStack(alignment: .leading, spacing: 12) {
                    Text("Add Requirements")
                        .font(.headline)
                        .padding(.horizontal)

                    if let portfolio = currentPortfolio, !portfolio.requirements.isEmpty {
                        // Show added requirements
                        ForEach(portfolio.requirements) { req in
                            HStack {
                                Image(systemName: "checkmark.circle.fill")
                                    .foregroundColor(.green)
                                VStack(alignment: .leading) {
                                    Text(req.procedure)
                                        .font(.subheadline).bold()
                                    Text("\(req.stages.count) stages • \(req.angles.count) angles")
                                        .font(.caption)
                                        .foregroundColor(.gray)
                                }
                                Spacer()
                            }
                            .padding()
                            .background(Color(UIColor.secondarySystemGroupedBackground))
                            .cornerRadius(10)
                            .padding(.horizontal)
                        }
                    } else {
                        // Empty state
                        VStack(spacing: 8) {
                            Image(systemName: "doc.text")
                                .font(.system(size: 30))
                                .foregroundColor(.gray)
                            Text("No requirements added yet")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 20)
                    }

                    // Add requirement button
                    Button(action: { showAddRequirementSheet = true }) {
                        HStack {
                            Image(systemName: "plus.circle.fill")
                            Text("Add Requirement")
                        }
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.blue)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                    }
                    .padding(.horizontal)
                }

                Spacer()

                // Done button
                Button(action: { isPresented = false }) {
                    Text(currentPortfolio?.requirements.isEmpty == true ? "Skip for Now" : "Done")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color(UIColor.secondarySystemGroupedBackground))
                        .foregroundColor(.primary)
                        .cornerRadius(10)
                }
                .padding(.horizontal)
                .padding(.bottom, 30)
            }
        }
        .navigationTitle("Add Requirements")
        .navigationBarTitleDisplayMode(.inline)
        .navigationBarBackButtonHidden(true)
        .sheet(isPresented: $showAddRequirementSheet) {
            AddRequirementSheet(isPresented: $showAddRequirementSheet, portfolioId: portfolioId)
        }
    }
}

// MARK: - Portfolio Detail View
struct PortfolioDetailView: View {
    let portfolio: Portfolio
    @ObservedObject var metadataManager = MetadataManager.shared
    @State private var showAddRequirementSheet = false
    @State private var showDeleteConfirmation = false
    @Environment(\.presentationMode) var presentationMode

    var currentPortfolio: Portfolio {
        metadataManager.getPortfolio(by: portfolio.id) ?? portfolio
    }

    var stats: (fulfilled: Int, total: Int) {
        metadataManager.getPortfolioStats(currentPortfolio)
    }

    var completionPercentage: Double {
        metadataManager.getPortfolioCompletionPercentage(currentPortfolio)
    }

    var body: some View {
        ZStack {
            Color.black.ignoresSafeArea()

            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    // Header stats card
                    VStack(spacing: 16) {
                        HStack {
                            VStack(alignment: .leading) {
                                Text("Progress")
                                    .font(AppFonts.subheadline)
                                    .foregroundColor(AppColors.textSecondary)
                                Text(String(format: "%.0f%%", completionPercentage))
                                    .font(AppFonts.interBold(36))
                                    .foregroundColor(completionPercentage >= 100 ? AppColors.success : AppColors.primary)
                            }

                            Spacer()

                            VStack(alignment: .trailing) {
                                Text("Photos")
                                    .font(AppFonts.subheadline)
                                    .foregroundColor(AppColors.textSecondary)
                                Text("\(stats.fulfilled) / \(stats.total)")
                                    .font(AppFonts.title2)
                                    .foregroundColor(AppColors.textPrimary)
                            }
                        }

                        // Progress bar
                        GeometryReader { geo in
                            ZStack(alignment: .leading) {
                                RoundedRectangle(cornerRadius: 6)
                                    .fill(AppColors.secondary.opacity(0.3))
                                    .frame(height: 12)

                                RoundedRectangle(cornerRadius: 6)
                                    .fill(completionPercentage >= 100 ? AppColors.success : AppColors.primary)
                                    .frame(width: geo.size.width * min(1.0, completionPercentage / 100), height: 12)
                            }
                        }
                        .frame(height: 12)
                    }
                    .padding()
                    .background(AppColors.surface.opacity(0.5))
                    .cornerRadius(12)

                    // Requirements section
                    VStack(alignment: .leading, spacing: 12) {
                        HStack {
                            Text("Requirements")
                                .font(AppFonts.headline)
                                .foregroundColor(AppColors.textPrimary)
                            Spacer()
                            Button(action: { showAddRequirementSheet = true }) {
                                HStack(spacing: 4) {
                                    Image(systemName: "plus.circle.fill")
                                    Text("Add")
                                }
                                .font(AppFonts.subheadline)
                                .foregroundColor(AppColors.primary)
                            }
                        }

                        if currentPortfolio.requirements.isEmpty {
                            VStack(spacing: 12) {
                                Image(systemName: "doc.text")
                                    .font(.system(size: 40))
                                    .foregroundColor(AppColors.textSecondary)
                                Text("No requirements yet")
                                    .font(AppFonts.subheadline)
                                    .foregroundColor(AppColors.textSecondary)
                                Text("Add requirements to specify what photos you need")
                                    .font(AppFonts.caption)
                                    .foregroundColor(AppColors.textSecondary.opacity(0.8))
                                    .multilineTextAlignment(.center)
                            }
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 30)
                        } else {
                            ForEach(currentPortfolio.requirements) { requirement in
                                RequirementStatusView(
                                    requirement: requirement,
                                    portfolioId: portfolio.id
                                )
                            }
                        }
                    }

                    Spacer(minLength: 50)
                }
                .padding()
            }
        }
        .navigationTitle(currentPortfolio.name)
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Menu {
                    Button(role: .destructive, action: { showDeleteConfirmation = true }) {
                        Label("Delete Portfolio", systemImage: "trash")
                    }
                } label: {
                    Image(systemName: "ellipsis.circle")
                        .foregroundColor(.blue)
                }
            }
        }
        .sheet(isPresented: $showAddRequirementSheet) {
            AddRequirementSheet(isPresented: $showAddRequirementSheet, portfolioId: portfolio.id)
        }
        .alert("Delete Portfolio", isPresented: $showDeleteConfirmation) {
            Button("Cancel", role: .cancel) { }
            Button("Delete", role: .destructive) {
                metadataManager.deletePortfolio(currentPortfolio)
                presentationMode.wrappedValue.dismiss()
            }
        } message: {
            Text("Are you sure you want to delete \"\(currentPortfolio.name)\"? This cannot be undone.")
        }
    }
}

// MARK: - Pie Progress View
struct PieProgressView: View {
    let progress: Double  // 0.0 to 1.0
    let isFulfilled: Bool

    var body: some View {
        ZStack {
            // Background circle
            Circle()
                .stroke(Color.gray.opacity(0.3), lineWidth: 3)

            // Progress arc
            Circle()
                .trim(from: 0, to: min(1.0, progress))
                .stroke(
                    isFulfilled ? Color.green : Color.blue,
                    style: StrokeStyle(lineWidth: 3, lineCap: .round)
                )
                .rotationEffect(.degrees(-90))

            // Center content
            if isFulfilled {
                Image(systemName: "checkmark")
                    .font(.system(size: 12, weight: .bold))
                    .foregroundColor(.green)
            } else if progress > 0 {
                Text(String(format: "%.0f", progress * 100))
                    .font(.system(size: 8, weight: .bold))
                    .foregroundColor(.blue)
            }
        }
    }
}

// MARK: - Requirement Status View
struct RequirementStatusView: View {
    let requirement: PortfolioRequirement
    let portfolioId: String
    @ObservedObject var metadataManager = MetadataManager.shared
    @ObservedObject var library = PhotoLibraryManager.shared
    @State private var isExpanded = false
    @State private var showEditSheet = false
    @State private var selectedPhotoStack: PhotoStackSelection? = nil

    var fulfilled: Int {
        metadataManager.getFulfilledCount(for: requirement)
    }

    var total: Int {
        requirement.totalRequired
    }

    var progress: Double {
        guard total > 0 else { return 0 }
        return Double(fulfilled) / Double(total)
    }

    var isFulfilled: Bool {
        metadataManager.isRequirementFulfilled(requirement)
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Header row
            Button(action: { withAnimation { isExpanded.toggle() } }) {
                HStack {
                    // Pie chart progress indicator
                    PieProgressView(progress: progress, isFulfilled: isFulfilled)
                        .frame(width: 28, height: 28)

                    VStack(alignment: .leading, spacing: 2) {
                        Text(requirement.procedure)
                            .font(AppFonts.geistSemiBold(15))
                            .foregroundColor(AppColors.textPrimary)
                        Text("\(fulfilled)/\(total) photos")
                            .font(AppFonts.caption)
                            .foregroundColor(AppColors.textSecondary)
                    }

                    Spacer()

                    // Edit button
                    Button(action: { showEditSheet = true }) {
                        Image(systemName: "pencil.circle.fill")
                            .foregroundColor(.blue)
                            .font(.title3)
                    }
                    .buttonStyle(BorderlessButtonStyle())
                    .padding(.trailing, 12)

                    Image(systemName: isExpanded ? "chevron.up" : "chevron.down")
                        .foregroundColor(AppColors.textSecondary)
                        .font(AppFonts.caption)
                }
                .padding()
                .background(AppColors.surface.opacity(0.5))
                .cornerRadius(isExpanded ? 0 : 10)
            }

            // Expanded details
            if isExpanded {
                VStack(alignment: .leading, spacing: 12) {
                    // Stage and angle breakdown with thumbnails
                    ForEach(requirement.stages, id: \.self) { stage in
                        VStack(alignment: .leading, spacing: 8) {
                            HStack {
                                Image(systemName: stage == "Preparation" ? "wrench.fill" : "checkmark.seal.fill")
                                    .foregroundColor(stage == "Preparation" ? AppColors.warning : AppColors.success)
                                    .font(AppFonts.caption)
                                Text(stage)
                                    .font(AppFonts.geistSemiBold(12))
                                    .foregroundColor(AppColors.textPrimary)
                            }

                            ForEach(requirement.angles, id: \.self) { angle in
                                let count = metadataManager.getPhotoCount(for: requirement, stage: stage, angle: angle)
                                let needed = requirement.angleCounts[angle] ?? 1
                                let satisfied = count >= needed
                                let assetIDs = metadataManager.getMatchingAssetIDs(
                                    procedure: requirement.procedure,
                                    stage: stage,
                                    angle: angle
                                )
                                let matchingAssets = library.assets.filter { assetIDs.contains($0.localIdentifier) }
                                let sortedAssets = matchingAssets.sorted { a, b in
                                    let ratingA = metadataManager.getRating(for: a.localIdentifier) ?? 0
                                    let ratingB = metadataManager.getRating(for: b.localIdentifier) ?? 0
                                    return ratingA > ratingB
                                }
                                let primaryAssets = Array(sortedAssets.prefix(needed))
                                let alternateAssets = Array(sortedAssets.dropFirst(needed))

                                VStack(alignment: .leading, spacing: 6) {
                                    HStack {
                                        Image(systemName: satisfied ? "checkmark.circle.fill" : "circle")
                                            .foregroundColor(satisfied ? AppColors.success : AppColors.textSecondary)
                                            .font(.system(size: 12))

                                        Text(angle)
                                            .font(AppFonts.caption)
                                            .foregroundColor(AppColors.textPrimary.opacity(0.8))

                                        Spacer()

                                        Text("\(min(count, needed))/\(needed)")
                                            .font(AppFonts.caption)
                                            .foregroundColor(satisfied ? AppColors.success : AppColors.textSecondary)
                                    }

                                    // Photo thumbnails section
                                    if !matchingAssets.isEmpty {
                                        ScrollView(.horizontal, showsIndicators: false) {
                                            HStack(spacing: 6) {
                                                // Primary photos (up to minimum needed)
                                                ForEach(primaryAssets, id: \.localIdentifier) { asset in
                                                    Button(action: {
                                                        selectedPhotoStack = PhotoStackSelection(
                                                            procedure: requirement.procedure,
                                                            stage: stage,
                                                            angle: angle,
                                                            assets: sortedAssets
                                                        )
                                                    }) {
                                                        ZStack(alignment: .bottomTrailing) {
                                                            AssetThumbnail(asset: asset)
                                                                .frame(width: 48, height: 48)
                                                                .clipShape(RoundedRectangle(cornerRadius: 6))
                                                                .overlay(
                                                                    RoundedRectangle(cornerRadius: 6)
                                                                        .stroke(AppColors.success, lineWidth: 2)
                                                                )

                                                            // Rating indicator
                                                            if let rating = metadataManager.getRating(for: asset.localIdentifier), rating > 0 {
                                                                HStack(spacing: 0) {
                                                                    Image(systemName: "star.fill")
                                                                        .font(.system(size: 6))
                                                                        .foregroundColor(.yellow)
                                                                    Text("\(rating)")
                                                                        .font(.system(size: 8, weight: .bold))
                                                                        .foregroundColor(.white)
                                                                }
                                                                .padding(.horizontal, 3)
                                                                .padding(.vertical, 1)
                                                                .background(Color.black.opacity(0.7))
                                                                .cornerRadius(4)
                                                                .offset(x: 2, y: 2)
                                                            }
                                                        }
                                                    }
                                                    .buttonStyle(BorderlessButtonStyle())
                                                }

                                                // Alternate photos (exceeding minimum)
                                                if !alternateAssets.isEmpty {
                                                    // Divider between primary and alternates
                                                    Rectangle()
                                                        .fill(AppColors.textSecondary.opacity(0.3))
                                                        .frame(width: 1, height: 40)
                                                        .padding(.horizontal, 4)

                                                    ForEach(alternateAssets, id: \.localIdentifier) { asset in
                                                        Button(action: {
                                                            selectedPhotoStack = PhotoStackSelection(
                                                                procedure: requirement.procedure,
                                                                stage: stage,
                                                                angle: angle,
                                                                assets: sortedAssets
                                                            )
                                                        }) {
                                                            ZStack(alignment: .bottomTrailing) {
                                                                AssetThumbnail(asset: asset)
                                                                    .frame(width: 48, height: 48)
                                                                    .clipShape(RoundedRectangle(cornerRadius: 6))
                                                                    .overlay(
                                                                        RoundedRectangle(cornerRadius: 6)
                                                                            .stroke(AppColors.textSecondary.opacity(0.5), lineWidth: 1)
                                                                    )
                                                                    .opacity(0.8)

                                                                // "Alt" badge for alternates
                                                                Text("Alt")
                                                                    .font(.system(size: 7, weight: .bold))
                                                                    .foregroundColor(.white)
                                                                    .padding(.horizontal, 3)
                                                                    .padding(.vertical, 1)
                                                                    .background(AppColors.secondary.opacity(0.8))
                                                                    .cornerRadius(3)
                                                                    .offset(x: 2, y: 2)
                                                            }
                                                        }
                                                        .buttonStyle(BorderlessButtonStyle())
                                                    }
                                                }
                                            }
                                            .padding(.vertical, 4)
                                        }
                                    }
                                }
                                .padding(.horizontal, 10)
                                .padding(.vertical, 8)
                                .background(AppColors.surface.opacity(0.4))
                                .cornerRadius(8)
                                .padding(.leading, 16)
                            }
                        }
                    }

                    // Delete button
                    Button(action: {
                        withAnimation {
                            metadataManager.removeRequirement(from: portfolioId, requirementId: requirement.id)
                        }
                    }) {
                        HStack {
                            Image(systemName: "trash")
                            Text("Remove Requirement")
                        }
                        .font(AppFonts.caption)
                        .foregroundColor(AppColors.error)
                    }
                    .padding(.top, 8)
                }
                .padding()
                .background(AppColors.surface.opacity(0.3))
            }
        }
        .background(AppColors.surface.opacity(0.5))
        .cornerRadius(10)
        .overlay(
            RoundedRectangle(cornerRadius: 10)
                .stroke(isFulfilled ? AppColors.success.opacity(0.5) : AppColors.secondary.opacity(0.3), lineWidth: 1)
        )
        .sheet(isPresented: $showEditSheet) {
            EditRequirementSheet(
                isPresented: $showEditSheet,
                portfolioId: portfolioId,
                requirement: requirement
            )
        }
        .sheet(item: $selectedPhotoStack) { selection in
            PhotoStackPopupView(selection: selection)
        }
    }
}

// MARK: - Photo Stack Selection
struct PhotoStackSelection: Identifiable {
    let id = UUID()
    let procedure: String
    let stage: String
    let angle: String
    let assets: [PHAsset]
}

// MARK: - Identifiable wrapper for PHAsset
struct IdentifiableAsset: Identifiable {
    let id: String
    let asset: PHAsset

    init(_ asset: PHAsset) {
        self.id = asset.localIdentifier
        self.asset = asset
    }
}

// MARK: - Photo Stack Popup View
struct PhotoStackPopupView: View {
    let selection: PhotoStackSelection
    @ObservedObject var metadataManager = MetadataManager.shared
    @Environment(\.presentationMode) var presentationMode
    @State private var selectedAssetWrapper: IdentifiableAsset? = nil

    var body: some View {
        NavigationView {
            ZStack {
                Color.black.ignoresSafeArea()

                ScrollView {
                    VStack(alignment: .leading, spacing: 16) {
                        // Header info
                        VStack(alignment: .leading, spacing: 4) {
                            Text(selection.procedure)
                                .font(.headline)
                                .foregroundColor(.white)
                            HStack(spacing: 8) {
                                HStack(spacing: 4) {
                                    Image(systemName: selection.stage == "Preparation" ? "wrench.fill" : "checkmark.seal.fill")
                                        .font(.caption2)
                                    Text(selection.stage)
                                        .font(.caption)
                                }
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(selection.stage == "Preparation" ? Color.orange.opacity(0.8) : Color.green.opacity(0.8))
                                .cornerRadius(4)

                                Text(selection.angle)
                                    .font(.caption)
                                    .padding(.horizontal, 8)
                                    .padding(.vertical, 4)
                                    .background(Color.purple.opacity(0.8))
                                    .cornerRadius(4)
                            }
                        }
                        .padding()

                        // Photo grid
                        LazyVGrid(columns: [
                            GridItem(.flexible(), spacing: 8),
                            GridItem(.flexible(), spacing: 8),
                            GridItem(.flexible(), spacing: 8)
                        ], spacing: 8) {
                            ForEach(selection.assets, id: \.localIdentifier) { asset in
                                Button(action: {
                                    selectedAssetWrapper = IdentifiableAsset(asset)
                                }) {
                                    GeometryReader { geometry in
                                        ZStack(alignment: .bottomTrailing) {
                                            AssetThumbnail(asset: asset)
                                                .frame(width: geometry.size.width, height: geometry.size.width)
                                                .clipped()

                                            // Rating stars overlay
                                            if let rating = metadataManager.getRating(for: asset.localIdentifier), rating > 0 {
                                                HStack(spacing: 1) {
                                                    ForEach(1...rating, id: \.self) { _ in
                                                        Image(systemName: "star.fill")
                                                            .font(.system(size: 8))
                                                            .foregroundColor(.yellow)
                                                    }
                                                }
                                                .padding(4)
                                                .background(Color.black.opacity(0.6))
                                                .cornerRadius(4)
                                                .padding(4)
                                            }
                                        }
                                    }
                                    .aspectRatio(1, contentMode: .fit)
                                }
                                .buttonStyle(PlainButtonStyle())
                            }
                        }
                        .padding(.horizontal)
                    }
                }
            }
            .navigationTitle("\(selection.assets.count) Photo\(selection.assets.count == 1 ? "" : "s")")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") { presentationMode.wrappedValue.dismiss() }
                }
            }
            .sheet(item: $selectedAssetWrapper) { wrapper in
                PortfolioPhotoDetailView(asset: wrapper.asset)
            }
        }
    }
}

// MARK: - Portfolio Photo Detail View (with edit/rating)
struct PortfolioPhotoDetailView: View {
    let asset: PHAsset
    @ObservedObject var metadataManager = MetadataManager.shared
    @Environment(\.presentationMode) var presentationMode
    @State private var image: UIImage? = nil
    @State private var isEditing = false

    var metadata: PhotoMetadata? {
        metadataManager.getMetadata(for: asset.localIdentifier)
    }

    var body: some View {
        NavigationView {
            ZStack {
                Color.black.ignoresSafeArea()

                VStack {
                    if let img = image {
                        Image(uiImage: img)
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                    } else {
                        ProgressView()
                    }

                    // Metadata display
                    if let meta = metadata {
                        VStack(alignment: .leading, spacing: 8) {
                            // Top row: Procedure and Tooth
                            HStack(spacing: 8) {
                                if let proc = meta.procedure {
                                    Text(proc)
                                        .font(.caption).bold()
                                        .padding(.horizontal, 8)
                                        .padding(.vertical, 4)
                                        .background(Color.blue.opacity(0.8))
                                        .cornerRadius(4)
                                }
                                if let tooth = meta.toothNumber {
                                    HStack(spacing: 2) {
                                        Image(systemName: "tooth")
                                            .font(.caption2)
                                        Text("#\(tooth)")
                                            .font(.caption).bold()
                                    }
                                    .padding(.horizontal, 8)
                                    .padding(.vertical, 4)
                                    .background(Color.green.opacity(0.8))
                                    .cornerRadius(4)
                                }
                                if let date = meta.toothDate {
                                    let formatter = DateFormatter()
                                    let _ = formatter.dateStyle = .short
                                    Text(formatter.string(from: date))
                                        .font(.caption2)
                                        .foregroundColor(.gray)
                                }
                            }

                            // Second row: Stage and Angle
                            HStack(spacing: 8) {
                                if let stage = meta.stage {
                                    HStack(spacing: 4) {
                                        Image(systemName: stage == "Preparation" ? "wrench.and.screwdriver" : "checkmark.seal")
                                            .font(.caption2)
                                        Text(stage)
                                            .font(.caption)
                                    }
                                    .padding(.horizontal, 8)
                                    .padding(.vertical, 4)
                                    .background(stage == "Preparation" ? Color.orange.opacity(0.8) : Color.green.opacity(0.8))
                                    .cornerRadius(4)
                                }
                                if let angle = meta.angle {
                                    Text(angle)
                                        .font(.caption)
                                        .padding(.horizontal, 8)
                                        .padding(.vertical, 4)
                                        .background(Color.purple.opacity(0.8))
                                        .cornerRadius(4)
                                }
                            }

                            // Rating row
                            HStack {
                                Text("Rating:")
                                    .font(.caption)
                                    .foregroundColor(.gray)
                                RatingView(
                                    rating: meta.rating ?? 0,
                                    assetID: asset.localIdentifier,
                                    metadataManager: metadataManager
                                )
                            }
                        }
                        .padding()
                        .background(Color.black.opacity(0.7))
                        .cornerRadius(10)
                        .padding()
                    }
                }
            }
            .navigationTitle("Photo")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Done") { presentationMode.wrappedValue.dismiss() }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Edit") { isEditing = true }
                }
            }
            .fullScreenCover(isPresented: $isEditing) {
                if let img = image { PhotoEditorView(inputImage: img) }
            }
            .onAppear {
                PhotoLibraryManager.shared.requestImage(for: asset) { loadedImg in
                    self.image = loadedImg
                }
            }
        }
    }
}

// MARK: - Edit Requirement Sheet
struct EditRequirementSheet: View {
    @Binding var isPresented: Bool
    let portfolioId: String
    let requirement: PortfolioRequirement
    @ObservedObject var metadataManager = MetadataManager.shared

    @State private var selectedProcedure: String
    @State private var selectedStages: Set<String>
    @State private var selectedAngles: Set<String>
    @State private var angleCounts: [String: Int]
    @State private var showDeleteConfirmation = false

    init(isPresented: Binding<Bool>, portfolioId: String, requirement: PortfolioRequirement) {
        self._isPresented = isPresented
        self.portfolioId = portfolioId
        self.requirement = requirement
        self._selectedProcedure = State(initialValue: requirement.procedure)
        self._selectedStages = State(initialValue: Set(requirement.stages))
        self._selectedAngles = State(initialValue: Set(requirement.angles))
        self._angleCounts = State(initialValue: requirement.angleCounts)
    }

    var canSave: Bool {
        !selectedProcedure.isEmpty && !selectedStages.isEmpty && !selectedAngles.isEmpty
    }

    var totalPhotos: Int {
        var total = 0
        for angle in selectedAngles {
            let count = angleCounts[angle] ?? 1
            total += selectedStages.count * count
        }
        return total
    }

    var body: some View {
        NavigationView {
            Form {
                // Procedure selection
                Section(header: Text("Procedure Type")) {
                    Picker("Procedure", selection: $selectedProcedure) {
                        Text("Select...").tag("")
                        ForEach(metadataManager.procedures.filter { $0 != "Unsorted Photos" }, id: \.self) { proc in
                            Text(proc).tag(proc)
                        }
                    }
                    .pickerStyle(.menu)
                }

                // Stage selection
                Section(header: Text("Stages Required")) {
                    ForEach(metadataManager.stages, id: \.self) { stage in
                        Button(action: {
                            if selectedStages.contains(stage) {
                                selectedStages.remove(stage)
                            } else {
                                selectedStages.insert(stage)
                            }
                        }) {
                            HStack {
                                Image(systemName: stage == "Preparation" ? "wrench.fill" : "checkmark.seal.fill")
                                    .foregroundColor(stage == "Preparation" ? .orange : .green)
                                Text(stage)
                                    .foregroundColor(.primary)
                                Spacer()
                                if selectedStages.contains(stage) {
                                    Image(systemName: "checkmark")
                                        .foregroundColor(.blue)
                                }
                            }
                        }
                    }
                }

                // Angle selection with per-angle counters
                Section(header: Text("Angles Required")) {
                    ForEach(metadataManager.angles, id: \.self) { angle in
                        HStack {
                            Button(action: {
                                if selectedAngles.contains(angle) {
                                    selectedAngles.remove(angle)
                                    angleCounts.removeValue(forKey: angle)
                                } else {
                                    selectedAngles.insert(angle)
                                    angleCounts[angle] = 1
                                }
                            }) {
                                HStack {
                                    Image(systemName: angleIcon(for: angle))
                                        .foregroundColor(.purple)
                                        .frame(width: 20)
                                    Text(angle)
                                        .foregroundColor(.primary)
                                }
                            }

                            Spacer()

                            if selectedAngles.contains(angle) {
                                HStack(spacing: 8) {
                                    Button(action: {
                                        let current = angleCounts[angle] ?? 1
                                        if current > 1 {
                                            angleCounts[angle] = current - 1
                                        }
                                    }) {
                                        Image(systemName: "minus.circle.fill")
                                            .foregroundColor(angleCounts[angle] ?? 1 > 1 ? .blue : .gray)
                                    }
                                    .buttonStyle(BorderlessButtonStyle())

                                    Text("\(angleCounts[angle] ?? 1)")
                                        .font(.subheadline).bold()
                                        .foregroundColor(.blue)
                                        .frame(minWidth: 20)

                                    Button(action: {
                                        let current = angleCounts[angle] ?? 1
                                        if current < 10 {
                                            angleCounts[angle] = current + 1
                                        }
                                    }) {
                                        Image(systemName: "plus.circle.fill")
                                            .foregroundColor(angleCounts[angle] ?? 1 < 10 ? .blue : .gray)
                                    }
                                    .buttonStyle(BorderlessButtonStyle())
                                }
                            } else {
                                Image(systemName: "circle")
                                    .foregroundColor(.gray.opacity(0.3))
                            }
                        }
                    }
                }

                // Summary
                if canSave {
                    Section(header: Text("Summary")) {
                        Text("Total: \(totalPhotos) photo\(totalPhotos == 1 ? "" : "s") required")
                            .font(.subheadline)
                    }
                }

                // Delete section
                Section {
                    Button(action: { showDeleteConfirmation = true }) {
                        HStack {
                            Image(systemName: "trash")
                            Text("Delete Requirement")
                        }
                        .foregroundColor(.red)
                    }
                }
            }
            .navigationTitle("Edit Requirement")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { isPresented = false }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        let updatedRequirement = PortfolioRequirement(
                            id: requirement.id,
                            procedure: selectedProcedure,
                            stages: Array(selectedStages),
                            angles: Array(selectedAngles),
                            angleCounts: angleCounts
                        )
                        metadataManager.updateRequirement(in: portfolioId, requirement: updatedRequirement)
                        isPresented = false
                    }
                    .disabled(!canSave)
                }
            }
            .alert("Delete Requirement", isPresented: $showDeleteConfirmation) {
                Button("Cancel", role: .cancel) { }
                Button("Delete", role: .destructive) {
                    metadataManager.removeRequirement(from: portfolioId, requirementId: requirement.id)
                    isPresented = false
                }
            } message: {
                Text("Are you sure you want to delete this requirement?")
            }
        }
    }

    func angleIcon(for angle: String) -> String {
        switch angle {
        case "Occlusal": return "arrow.down"
        case "Buccal/Facial": return "arrow.left"
        case "Lingual": return "arrow.right"
        case "Proximal": return "arrow.left.arrow.right"
        case "Mesial": return "arrow.up.left"
        case "Distal": return "arrow.up.right"
        default: return "questionmark"
        }
    }
}

// MARK: - Add Requirement Sheet
struct AddRequirementSheet: View {
    @Binding var isPresented: Bool
    let portfolioId: String
    @ObservedObject var metadataManager = MetadataManager.shared

    @State private var selectedProcedure: String = ""
    @State private var selectedStages: Set<String> = []
    @State private var selectedAngles: Set<String> = []
    @State private var angleCounts: [String: Int] = [:]  // Per-angle photo counts

    var canAdd: Bool {
        !selectedProcedure.isEmpty && !selectedStages.isEmpty && !selectedAngles.isEmpty
    }

    var totalPhotos: Int {
        var total = 0
        for angle in selectedAngles {
            let count = angleCounts[angle] ?? 1
            total += selectedStages.count * count
        }
        return total
    }

    var body: some View {
        NavigationView {
            Form {
                // Procedure selection
                Section(header: Text("Procedure Type")) {
                    Picker("Procedure", selection: $selectedProcedure) {
                        Text("Select...").tag("")
                        ForEach(metadataManager.procedures.filter { $0 != "Unsorted Photos" }, id: \.self) { proc in
                            Text(proc).tag(proc)
                        }
                    }
                    .pickerStyle(.menu)
                }

                // Stage selection
                Section(header: Text("Stages Required")) {
                    ForEach(metadataManager.stages, id: \.self) { stage in
                        Button(action: {
                            if selectedStages.contains(stage) {
                                selectedStages.remove(stage)
                            } else {
                                selectedStages.insert(stage)
                            }
                        }) {
                            HStack {
                                Image(systemName: stage == "Preparation" ? "wrench.fill" : "checkmark.seal.fill")
                                    .foregroundColor(stage == "Preparation" ? .orange : .green)
                                Text(stage)
                                    .foregroundColor(.primary)
                                Spacer()
                                if selectedStages.contains(stage) {
                                    Image(systemName: "checkmark")
                                        .foregroundColor(.blue)
                                }
                            }
                        }
                    }

                    Button(action: {
                        if selectedStages.count == metadataManager.stages.count {
                            selectedStages.removeAll()
                        } else {
                            selectedStages = Set(metadataManager.stages)
                        }
                    }) {
                        Text(selectedStages.count == metadataManager.stages.count ? "Deselect All" : "Select All")
                            .font(.caption)
                            .foregroundColor(.blue)
                    }
                }

                // Angle selection with per-angle counters
                Section(header: Text("Angles Required")) {
                    ForEach(metadataManager.angles, id: \.self) { angle in
                        HStack {
                            Button(action: {
                                if selectedAngles.contains(angle) {
                                    selectedAngles.remove(angle)
                                    angleCounts.removeValue(forKey: angle)
                                } else {
                                    selectedAngles.insert(angle)
                                    angleCounts[angle] = 1
                                }
                            }) {
                                HStack {
                                    Image(systemName: angleIcon(for: angle))
                                        .foregroundColor(.purple)
                                        .frame(width: 20)
                                    Text(angle)
                                        .foregroundColor(.primary)
                                }
                            }

                            Spacer()

                            if selectedAngles.contains(angle) {
                                // Photo count stepper for selected angles
                                HStack(spacing: 8) {
                                    Button(action: {
                                        let current = angleCounts[angle] ?? 1
                                        if current > 1 {
                                            angleCounts[angle] = current - 1
                                        }
                                    }) {
                                        Image(systemName: "minus.circle.fill")
                                            .foregroundColor(angleCounts[angle] ?? 1 > 1 ? .blue : .gray)
                                    }
                                    .buttonStyle(BorderlessButtonStyle())

                                    Text("\(angleCounts[angle] ?? 1)")
                                        .font(.subheadline).bold()
                                        .foregroundColor(.blue)
                                        .frame(minWidth: 20)

                                    Button(action: {
                                        let current = angleCounts[angle] ?? 1
                                        if current < 10 {
                                            angleCounts[angle] = current + 1
                                        }
                                    }) {
                                        Image(systemName: "plus.circle.fill")
                                            .foregroundColor(angleCounts[angle] ?? 1 < 10 ? .blue : .gray)
                                    }
                                    .buttonStyle(BorderlessButtonStyle())
                                }
                            } else {
                                Image(systemName: "circle")
                                    .foregroundColor(.gray.opacity(0.3))
                            }
                        }
                    }

                    Button(action: {
                        if selectedAngles.count == metadataManager.angles.count {
                            selectedAngles.removeAll()
                            angleCounts.removeAll()
                        } else {
                            selectedAngles = Set(metadataManager.angles)
                            for angle in metadataManager.angles {
                                if angleCounts[angle] == nil {
                                    angleCounts[angle] = 1
                                }
                            }
                        }
                    }) {
                        Text(selectedAngles.count == metadataManager.angles.count ? "Deselect All" : "Select All")
                            .font(.caption)
                            .foregroundColor(.blue)
                    }
                }

                // Summary
                if canAdd {
                    Section(header: Text("Summary")) {
                        VStack(alignment: .leading, spacing: 8) {
                            Text("This will require \(totalPhotos) photo\(totalPhotos == 1 ? "" : "s"):")
                                .font(AppFonts.subheadline)
                            Text("• \(selectedStages.count) stage\(selectedStages.count == 1 ? "" : "s")")
                                .font(.caption)
                                .foregroundColor(.gray)
                            ForEach(Array(selectedAngles).sorted(), id: \.self) { angle in
                                let count = angleCounts[angle] ?? 1
                                Text("• \(angle): \(count) photo\(count == 1 ? "" : "s") per stage")
                                    .font(.caption)
                                    .foregroundColor(.gray)
                            }
                        }
                    }
                }
            }
            .navigationTitle("Add Requirement")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { isPresented = false }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Add") {
                        let requirement = PortfolioRequirement(
                            procedure: selectedProcedure,
                            stages: Array(selectedStages),
                            angles: Array(selectedAngles),
                            angleCounts: angleCounts
                        )
                        metadataManager.addRequirement(to: portfolioId, requirement: requirement)
                        isPresented = false
                    }
                    .disabled(!canAdd)
                }
            }
        }
    }

    func angleIcon(for angle: String) -> String {
        switch angle {
        case "Occlusal": return "arrow.down"
        case "Buccal/Facial": return "arrow.left"
        case "Lingual": return "arrow.right"
        case "Proximal": return "arrow.left.arrow.right"
        case "Mesial": return "arrow.up.left"
        case "Distal": return "arrow.up.right"
        default: return "questionmark"
        }
    }
}
