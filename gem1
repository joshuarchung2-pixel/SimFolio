import SwiftUI
import AVFoundation
import Photos
import Combine
import UIKit
import CoreImage
import CoreImage.CIFilterBuiltins

// MARK: - MAIN ENTRY POINT
struct ContentView: View {
    @State private var selectedTab = 0 // Track tab selection
    
    var body: some View {
        TabView(selection: $selectedTab) {
            DentalCameraSetupView(selectedTab: $selectedTab)
                .tabItem {
                    Label("Camera", systemImage: "camera.fill")
                }
                .tag(0)
            
            GalleryView()
                .tabItem {
                    Label("Gallery", systemImage: "photo.on.rectangle")
                }
                .tag(1)
        }
        .preferredColorScheme(.dark)
        .onAppear {
            PhotoLibraryManager.shared.createAlbumIfNeeded()
        }
    }
}

// MARK: - PHOTO METADATA MODEL
struct ToothEntry: Codable, Hashable, Identifiable {
    var id: String { "\(procedure)-\(toothNumber)-\(dateString)" }
    let procedure: String
    let toothNumber: Int
    let date: Date

    var dateString: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        return formatter.string(from: date)
    }

    var displayString: String {
        "Tooth \(toothNumber) - \(dateString)"
    }
}

struct PhotoMetadata: Codable {
    var procedure: String?
    var toothNumber: Int?
    var toothDate: Date?
    var stage: String?  // "Preparation" or "Restoration"
    var angle: String?  // "Occlusal", "Buccal/Facial", etc.
    var rating: Int?    // 1-10

    var toothEntry: ToothEntry? {
        guard let proc = procedure, let num = toothNumber, let date = toothDate else { return nil }
        return ToothEntry(procedure: proc, toothNumber: num, date: date)
    }

    var isComplete: Bool {
        procedure != nil && toothNumber != nil && toothDate != nil && stage != nil && angle != nil
    }

    var summaryText: String {
        var parts: [String] = []
        if let p = procedure { parts.append(p) }
        if let t = toothNumber { parts.append("#\(t)") }
        if let s = stage { parts.append(s.prefix(4).description) }
        if let a = angle { parts.append(a) }
        return parts.isEmpty ? "Choose procedure" : parts.joined(separator: " Â· ")
    }
}

// MARK: - METADATA MANAGER (PERSISTENCE)
class MetadataManager: ObservableObject {
    static let shared = MetadataManager()

    // Procedure options (can add, cannot delete base ones)
    @Published var procedures: [String] = ["Class 1", "Class 2", "Class 3", "Crown"]
    private let baseProcedures = ["Class 1", "Class 2", "Class 3", "Crown"]

    // Stage options (fixed)
    let stages: [String] = ["Preparation", "Restoration"]

    // Angle options (fixed)
    let angles: [String] = ["Occlusal", "Buccal/Facial", "Lingual", "Proximal", "Mesial", "Distal", "Other"]

    // Tooth entries history per procedure
    @Published var toothHistory: [String: [ToothEntry]] = [:]  // procedure -> [ToothEntry]

    // Asset metadata map
    @Published var assetMetadata: [String: PhotoMetadata] = [:]  // assetID -> PhotoMetadata

    // UserDefaults keys
    private let proceduresKey = "DentalPortfolio_Procedures_v2"
    private let toothHistoryKey = "DentalPortfolio_ToothHistory"
    private let assetMetadataKey = "DentalPortfolio_AssetMetadata"

    init() {
        loadData()
    }

    func addProcedure(_ procedure: String) {
        guard !procedure.isEmpty && !procedures.contains(procedure) else { return }
        procedures.append(procedure)
        saveProcedures()
    }

    func canDeleteProcedure(_ procedure: String) -> Bool {
        return !baseProcedures.contains(procedure)
    }

    func deleteProcedure(_ procedure: String) {
        guard canDeleteProcedure(procedure) else { return }
        procedures.removeAll { $0 == procedure }
        saveProcedures()
    }

    func addToothEntry(_ entry: ToothEntry) {
        var entries = toothHistory[entry.procedure] ?? []
        // Check if this exact tooth/date combo already exists
        if !entries.contains(where: { $0.toothNumber == entry.toothNumber && Calendar.current.isDate($0.date, inSameDayAs: entry.date) }) {
            entries.append(entry)
            toothHistory[entry.procedure] = entries
            saveToothHistory()
        }
    }

    func getToothEntries(for procedure: String) -> [ToothEntry] {
        return toothHistory[procedure] ?? []
    }

    func assignMetadata(_ metadata: PhotoMetadata, to assetID: String) {
        assetMetadata[assetID] = metadata

        // Also add to tooth history if applicable
        if let entry = metadata.toothEntry {
            addToothEntry(entry)
        }

        saveAssetMetadata()
    }

    func getMetadata(for assetID: String) -> PhotoMetadata? {
        return assetMetadata[assetID]
    }

    func setRating(_ rating: Int, for assetID: String) {
        var metadata = assetMetadata[assetID] ?? PhotoMetadata()
        metadata.rating = max(1, min(10, rating))
        assetMetadata[assetID] = metadata
        saveAssetMetadata()
    }

    func getRating(for assetID: String) -> Int? {
        return assetMetadata[assetID]?.rating
    }

    // MARK: - Persistence
    private func saveProcedures() {
        UserDefaults.standard.set(procedures, forKey: proceduresKey)
    }

    private func saveToothHistory() {
        if let encoded = try? JSONEncoder().encode(toothHistory) {
            UserDefaults.standard.set(encoded, forKey: toothHistoryKey)
        }
    }

    private func saveAssetMetadata() {
        if let encoded = try? JSONEncoder().encode(assetMetadata) {
            UserDefaults.standard.set(encoded, forKey: assetMetadataKey)
        }
    }

    private func loadData() {
        // Load procedures
        if let procs = UserDefaults.standard.stringArray(forKey: proceduresKey) {
            // Merge with base procedures to ensure they exist
            var merged = baseProcedures
            for p in procs where !merged.contains(p) {
                merged.append(p)
            }
            procedures = merged
        }

        // Load tooth history
        if let data = UserDefaults.standard.data(forKey: toothHistoryKey),
           let decoded = try? JSONDecoder().decode([String: [ToothEntry]].self, from: data) {
            toothHistory = decoded
        }

        // Load asset metadata
        if let data = UserDefaults.standard.data(forKey: assetMetadataKey),
           let decoded = try? JSONDecoder().decode([String: PhotoMetadata].self, from: data) {
            assetMetadata = decoded
        }
    }
}

// MARK: - Legacy TagManager (kept for backward compatibility)
class TagManager: ObservableObject {
    static let shared = TagManager()

    @Published var procedureTags: [String] = []
    @Published var otherTags: [String] = []
    @Published var assetProcedureMap: [String: String] = [:]
    @Published var assetOtherTagsMap: [String: [String]] = [:]

    private let procedureKey = "DentalPortfolio_Procedures"
    private let otherTagsKey = "DentalPortfolio_OtherTags"
    private let assetProcMapKey = "DentalPortfolio_AssetProcMap"
    private let assetOtherMapKey = "DentalPortfolio_AssetOtherMap"

    init() {
        loadData()
        if procedureTags.isEmpty {
            procedureTags = ["Crown", "Bridge", "Veneer", "Implant", "Denture", "Ortho"]
            saveProcedures()
        }
        if otherTags.isEmpty {
            otherTags = ["Upper", "Lower", "Anterior", "Posterior", "Prep", "Restoration"]
            saveOtherTags()
        }
    }

    func addProcedure(_ tag: String) {
        if !procedureTags.contains(tag) && !tag.isEmpty { procedureTags.append(tag); saveProcedures() }
    }
    func deleteProcedure(_ tag: String) {
        procedureTags.removeAll { $0 == tag }; saveProcedures()
    }
    func addOtherTag(_ tag: String) {
        if !otherTags.contains(tag) && !tag.isEmpty { otherTags.append(tag); saveOtherTags() }
    }
    func deleteOtherTag(_ tag: String) {
        otherTags.removeAll { $0 == tag }; saveOtherTags()
    }
    func assign(procedure: String?, otherTags: [String], to assetID: String) {
        if let proc = procedure { assetProcedureMap[assetID] = proc }
        assetOtherTagsMap[assetID] = otherTags
        saveMaps()
    }
    func getProcedure(for assetID: String) -> String? { return assetProcedureMap[assetID] }
    func getOtherTags(for assetID: String) -> [String] { return assetOtherTagsMap[assetID] ?? [] }

    private func saveProcedures() { UserDefaults.standard.set(procedureTags, forKey: procedureKey) }
    private func saveOtherTags() { UserDefaults.standard.set(otherTags, forKey: otherTagsKey) }
    private func saveMaps() {
        UserDefaults.standard.set(assetProcedureMap, forKey: assetProcMapKey)
        UserDefaults.standard.set(assetOtherTagsMap, forKey: assetOtherMapKey)
    }
    private func loadData() {
        if let p = UserDefaults.standard.stringArray(forKey: procedureKey) { procedureTags = p }
        if let o = UserDefaults.standard.stringArray(forKey: otherTagsKey) { otherTags = o }
        if let pm = UserDefaults.standard.dictionary(forKey: assetProcMapKey) as? [String: String] { assetProcedureMap = pm }
        if let om = UserDefaults.standard.dictionary(forKey: assetOtherMapKey) as? [String: [String]] { assetOtherTagsMap = om }
    }
}

// MARK: - CAMERA SERVICE (AVFoundation)
class CameraService: NSObject, ObservableObject, AVCapturePhotoCaptureDelegate {
    @Published var session = AVCaptureSession()
    @Published var capturedImage: UIImage? = nil
    
    // Exposure & Flash State
    @Published var currentExposure: Float = 0.0
    @Published var minExposure: Float = -2.0
    @Published var maxExposure: Float = 2.0
    @Published var flashMode: AVCaptureDevice.FlashMode = .off

    // Zoom State
    @Published var currentZoom: CGFloat = 1.0
    @Published var minZoom: CGFloat = 1.0
    @Published var maxZoom: CGFloat = 10.0
    
    private let output = AVCapturePhotoOutput()
    private var videoInput: AVCaptureDeviceInput?
    private var currentExposureBias: Float = 0.0
    
    override init() {
        super.init()
        checkPermissions()
    }
    
    func checkPermissions() {
        switch AVCaptureDevice.authorizationStatus(for: .video) {
        case .notDetermined:
            AVCaptureDevice.requestAccess(for: .video) { granted in
                if granted { self.setupCamera() }
            }
        case .authorized:
            setupCamera()
        default: break
        }
    }
    
    func setupCamera() {
        DispatchQueue.global(qos: .userInitiated).async {
            self.session.beginConfiguration()
            if let device = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back),
               let input = try? AVCaptureDeviceInput(device: device) {
                self.videoInput = input
                if self.session.canAddInput(input) { self.session.addInput(input) }
                if self.session.canAddOutput(self.output) { self.session.addOutput(self.output) }

                // Initialize Exposure Limits
                DispatchQueue.main.async {
                    self.minExposure = device.minExposureTargetBias
                    self.maxExposure = device.maxExposureTargetBias
                    self.currentExposure = 0.0
                }

                // Initialize Zoom Limits
                DispatchQueue.main.async {
                    self.minZoom = device.minAvailableVideoZoomFactor
                    self.maxZoom = min(device.maxAvailableVideoZoomFactor, 10.0)
                    self.currentZoom = device.videoZoomFactor
                }

                // Enable continuous auto-focus by default
                self.enableContinuousAutoFocus()
            }
            self.session.commitConfiguration()
            self.session.startRunning()
        }
    }

    // Enable continuous auto-focus and auto-exposure
    func enableContinuousAutoFocus() {
        guard let device = videoInput?.device else { return }
        do {
            try device.lockForConfiguration()

            if device.isFocusModeSupported(.continuousAutoFocus) {
                device.focusMode = .continuousAutoFocus
            }

            if device.isExposureModeSupported(.continuousAutoExposure) {
                device.exposureMode = .continuousAutoExposure
            }

            device.unlockForConfiguration()
        } catch {
            print("Failed to enable continuous auto-focus: \(error)")
        }
    }
    
    // Tap to Focus (One Shot)
    func focusAndExpose(at devicePoint: CGPoint) {
        guard let device = videoInput?.device else { return }
        do {
            try device.lockForConfiguration()

            if device.isFocusPointOfInterestSupported && device.isFocusModeSupported(.autoFocus) {
                device.focusPointOfInterest = devicePoint
                device.focusMode = .autoFocus
            }

            if device.isExposurePointOfInterestSupported && device.isExposureModeSupported(.autoExpose) {
                device.exposurePointOfInterest = devicePoint
                device.exposureMode = .autoExpose
                // Preserve current exposure bias - don't reset to 0
                device.setExposureTargetBias(currentExposure, completionHandler: nil)
            }

            device.unlockForConfiguration()
        } catch {
            print("Failed to lock for focus: \(error)")
        }
    }
    
    // Long Press to Lock (AE/AF Lock)
    func lockAEAF(at devicePoint: CGPoint) {
        guard let device = videoInput?.device else { return }
        do {
            try device.lockForConfiguration()

            if device.isFocusPointOfInterestSupported && device.isFocusModeSupported(.autoFocus) {
                device.focusPointOfInterest = devicePoint
                // Start autofocus, then it will lock when converged.
                // Alternatively, .locked is used to lock at current lens pos,
                // but usually we want to focus on the point *then* lock.
                // .autoFocus does exactly that: scan once, then stop (lock).
                device.focusMode = .autoFocus
            }

            if device.isExposurePointOfInterestSupported && device.isExposureModeSupported(.autoExpose) {
                device.exposurePointOfInterest = devicePoint
                device.exposureMode = .autoExpose
                // Preserve current exposure bias - don't reset to 0
                device.setExposureTargetBias(currentExposure, completionHandler: nil)
            }

            device.unlockForConfiguration()
        } catch {
            print("Failed to lock AE/AF: \(error)")
        }
    }
    
    func adjustExposure(delta: Float) {
        guard let device = videoInput?.device else { return }
        do {
            try device.lockForConfiguration()
            let newBias = max(device.minExposureTargetBias, min(device.maxExposureTargetBias, currentExposure + delta))
            device.setExposureTargetBias(newBias, completionHandler: nil)

            DispatchQueue.main.async {
                self.currentExposure = newBias
            }

            device.unlockForConfiguration()
        } catch {
            print("Failed to set exposure: \(error)")
        }
    }

    func setZoom(factor: CGFloat) {
        guard let device = videoInput?.device else { return }
        do {
            try device.lockForConfiguration()
            let clampedZoom = max(device.minAvailableVideoZoomFactor, min(min(device.maxAvailableVideoZoomFactor, 10.0), factor))
            device.videoZoomFactor = clampedZoom

            DispatchQueue.main.async {
                self.currentZoom = clampedZoom
            }

            device.unlockForConfiguration()
        } catch {
            print("Failed to set zoom: \(error)")
        }
    }
    
    func takePhoto() {
        let settings = AVCapturePhotoSettings()
        // Check if flash is supported
        if output.supportedFlashModes.contains(flashMode) {
            settings.flashMode = flashMode
        }
        output.capturePhoto(with: settings, delegate: self)
    }
    
    func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingPhoto photo: AVCapturePhoto, error: Error?) {
        guard let data = photo.fileDataRepresentation(), let image = UIImage(data: data) else { return }
        DispatchQueue.main.async {
            self.capturedImage = image
        }
    }
    
    func retake() {
        DispatchQueue.main.async { self.capturedImage = nil }
    }
    
    func flipCamera() {
        guard let input = videoInput else { return }
        session.beginConfiguration()
        session.removeInput(input)
        
        let newPosition: AVCaptureDevice.Position = input.device.position == .back ? .front : .back
        if let newDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: newPosition),
           let newInput = try? AVCaptureDeviceInput(device: newDevice) {
            if session.canAddInput(newInput) {
                session.addInput(newInput)
                videoInput = newInput
            } else {
                session.addInput(input)
            }
        } else {
            session.addInput(input)
        }
        
        // Refresh exposure limits for new device
        if let device = videoInput?.device {
            DispatchQueue.main.async {
                self.minExposure = device.minExposureTargetBias
                self.maxExposure = device.maxExposureTargetBias
                self.currentExposure = 0.0
                self.minZoom = device.minAvailableVideoZoomFactor
                self.maxZoom = min(device.maxAvailableVideoZoomFactor, 10.0)
                self.currentZoom = device.videoZoomFactor
            }
            // Re-enable continuous auto-focus for the new camera
            enableContinuousAutoFocus()
        }

        session.commitConfiguration()
    }
}

// MARK: - 1. CAMERA TAB UI
struct DentalCameraSetupView: View {
    @Binding var selectedTab: Int
    
    @StateObject private var cameraService = CameraService()
    
    // UI State
    @State private var showGrid = false
    @State private var ghostImage: UIImage? = nil
    @State private var ghostOpacity: Double = 0.5
    @State private var isGhostPickerPresented = false
    @State private var isOptionsExpanded = false // Unified Options Menu
    
    // Focus/Exposure State
    @State private var focusLocation: CGPoint? = nil
    @State private var showFocusSquare = false
    @State private var isAELocked = false
    @State private var showShutterEffect = false

    // Zoom State
    @State private var baseZoomFactor: CGFloat = 1.0
    @State private var showZoomDial = false
    @State private var zoomDialTimer: DispatchWorkItem?

    // Focus Square Timer
    @State private var focusSquareTimer: DispatchWorkItem?

    // Photo Metadata State (new unified system)
    @State private var currentMetadata = PhotoMetadata()
    @State private var isInfoPillOpen = false
    @ObservedObject var metadataManager = MetadataManager.shared
    
    // Computed property for visual slider position
    // Maps actual exposure bias [min, max] to visual slider height [-70, 70]
    var exposureVisualOffset: CGFloat {
        let range = cameraService.maxExposure - cameraService.minExposure
        guard range > 0 else { return 0 }
        let percentage = (cameraService.currentExposure - cameraService.minExposure) / range
        let visualHeight: CGFloat = 140
        return (CGFloat(percentage) * visualHeight) - (visualHeight / 2)
    }
    
    var body: some View {
        ZStack(alignment: .top) {
            Color.black.ignoresSafeArea()
            
            // 1. CAMERA PREVIEW (Always active)
            CameraPreview(
                session: cameraService.session,
                onTap: { point in
                    isAELocked = false
                    showFocusSquare = true
                    cameraService.focusAndExpose(at: point)
                },
                onLongPress: { point in
                    isAELocked = true
                    cameraService.lockAEAF(at: point)
                    let generator = UINotificationFeedbackGenerator()
                    generator.notificationOccurred(.success)
                },
                onPan: { delta in
                    // Only allow exposure adjustment when focus box is visible
                    if showFocusSquare || isAELocked {
                        cameraService.adjustExposure(delta: Float(delta) * 0.005) // Reduced sensitivity by 50%

                        // Extend focus square linger time by 2x when adjusting exposure
                        if !isAELocked {
                            focusSquareTimer?.cancel()
                            let workItem = DispatchWorkItem {
                                if !isAELocked {
                                    withAnimation { showFocusSquare = false }
                                    // Re-enable continuous auto-focus after focus box disappears
                                    cameraService.enableContinuousAutoFocus()
                                }
                            }
                            focusSquareTimer = workItem
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.4, execute: workItem) // 2x default (1.2s)
                        }
                    }
                },
                onPinch: { scale in
                    if scale == 0.0 {
                        // Pinch gesture ended, update base zoom
                        baseZoomFactor = cameraService.currentZoom
                    } else {
                        // Pinch gesture in progress
                        let newZoom = baseZoomFactor * scale
                        cameraService.setZoom(factor: newZoom)

                        // Show zoom dial
                        showZoomDial = true
                        zoomDialTimer?.cancel()
                        let workItem = DispatchWorkItem {
                            withAnimation { showZoomDial = false }
                        }
                        zoomDialTimer = workItem
                        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5, execute: workItem)
                    }
                },
                touchPoint: $focusLocation
            )
            .ignoresSafeArea()
            
            // 1.5 CAPTURED IMAGE OVERLAY (Review Mode)
            if let captured = cameraService.capturedImage {
                Image(uiImage: captured)
                    .resizable()
                    .aspectRatio(contentMode: .fill) // Matches camera preview
                    .ignoresSafeArea()
                    .zIndex(1)
            }
            
            // 2. FOCUS INDICATOR
            if let loc = focusLocation, cameraService.capturedImage == nil {
                ZStack {
                    // Focus Box with Inner Ticks
                    ZStack {
                        Rectangle().stroke(Color.yellow, lineWidth: 1.5).frame(width: 75, height: 75)
                        Rectangle().fill(Color.yellow).frame(width: 1.5, height: 10).offset(y: -32.5)
                        Rectangle().fill(Color.yellow).frame(width: 1.5, height: 10).offset(y: 32.5)
                        Rectangle().fill(Color.yellow).frame(width: 10, height: 1.5).offset(x: -32.5)
                        Rectangle().fill(Color.yellow).frame(width: 10, height: 1.5).offset(x: 32.5)
                    }
                    .opacity(showFocusSquare || isAELocked ? 1 : 0)
                    
                    // Native-Style Exposure Slider
                    if showFocusSquare || isAELocked {
                        // Line above sun icon
                        let sunY = -exposureVisualOffset
                        let topLineHeight = max(0, 70 + sunY - 12) // From top (-70) to just above sun
                        let bottomLineHeight = max(0, 70 - sunY - 12) // From just below sun to bottom (+70)

                        // Top line segment (above sun)
                        if topLineHeight > 0 {
                            Rectangle()
                                .fill(Color.yellow)
                                .frame(width: 1, height: topLineHeight)
                                .offset(x: 65, y: -70 + topLineHeight / 2)
                                .shadow(radius: 1)
                                .opacity(0.8)
                        }

                        // Bottom line segment (below sun)
                        if bottomLineHeight > 0 {
                            Rectangle()
                                .fill(Color.yellow)
                                .frame(width: 1, height: bottomLineHeight)
                                .offset(x: 65, y: 70 - bottomLineHeight / 2)
                                .shadow(radius: 1)
                                .opacity(0.8)
                        }

                        Image(systemName: "sun.max.fill")
                            .font(.system(size: 20))
                            .foregroundColor(.yellow)
                            .shadow(radius: 2)
                            .offset(x: 65, y: sunY)
                    }
                }
                .position(loc)
                .id(loc)
                .transition(.opacity.animation(.easeInOut(duration: 0.2)))
                .onChange(of: loc) { _ in
                    showFocusSquare = true
                    if !isAELocked {
                        focusSquareTimer?.cancel()
                        let workItem = DispatchWorkItem {
                            if !isAELocked {
                                withAnimation { showFocusSquare = false }
                                // Re-enable continuous auto-focus after focus box disappears
                                cameraService.enableContinuousAutoFocus()
                            }
                        }
                        focusSquareTimer = workItem
                        DispatchQueue.main.asyncAfter(deadline: .now() + 1.2, execute: workItem) // Default linger time
                    }
                }
                
                if isAELocked {
                    Text("AE/AF LOCK")
                        .font(.caption).fontWeight(.bold).foregroundColor(.black)
                        .padding(.vertical, 4).padding(.horizontal, 8)
                        .background(Color.yellow).cornerRadius(4)
                        .padding(.top, 120)
                        .transition(.opacity)
                }
            }
            
            // 3. OVERLAYS (Only visible when NOT reviewing)
            if cameraService.capturedImage == nil {
                if let ghost = ghostImage {
                    Image(uiImage: ghost)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .opacity(ghostOpacity).allowsHitTesting(false).ignoresSafeArea()
                }
                if showGrid { CameraGridOverlay().allowsHitTesting(false) }

                // Zoom Dial
                if showZoomDial {
                    VStack {
                        Spacer()
                        ZoomDialView(
                            currentZoom: cameraService.currentZoom,
                            minZoom: cameraService.minZoom,
                            maxZoom: cameraService.maxZoom
                        )
                        .transition(.opacity.combined(with: .scale))
                        .padding(.bottom, 180)
                    }
                    .allowsHitTesting(false)
                }
            }
            
            // 4. CONTROLS LAYER
            VStack {
                // TOP BAR
                ZStack(alignment: .top) {
                    // Center: Unified Photo Info Pill
                    PhotoInfoPillView(
                        metadata: $currentMetadata,
                        isDropdownOpen: $isInfoPillOpen
                    )
                    .zIndex(10)

                    // Right: Unified Options Button (Expanding Downward)
                    if cameraService.capturedImage == nil {
                        HStack {
                            Spacer()
                            VStack(alignment: .trailing, spacing: 10) {
                                Button(action: { withAnimation { isOptionsExpanded.toggle() } }) {
                                    Image(systemName: isOptionsExpanded ? "chevron.up.circle.fill" : "slider.horizontal.3")
                                        .font(.title2)
                                        .padding(10)
                                        .background(Color.black.opacity(0.6))
                                        .clipShape(Circle())
                                        .foregroundColor(.white)
                                }

                                if isOptionsExpanded {
                                    // Flash Toggle
                                    Button(action: {
                                        switch cameraService.flashMode {
                                        case .off: cameraService.flashMode = .on
                                        case .on: cameraService.flashMode = .auto
                                        default: cameraService.flashMode = .off
                                        }
                                    }) {
                                        Image(systemName: cameraService.flashMode == .off ? "bolt.slash.fill" : (cameraService.flashMode == .on ? "bolt.fill" : "bolt.badge.a.fill"))
                                            .font(.title2).padding(10)
                                            .background(Color.black.opacity(0.6)).clipShape(Circle()).foregroundColor(cameraService.flashMode == .off ? .white : .yellow)
                                    }
                                    .transition(.move(edge: .top).combined(with: .opacity))

                                    // Grid Toggle
                                    Button(action: { showGrid.toggle() }) {
                                        Image(systemName: showGrid ? "square" : "grid")
                                            .font(.title2).padding(10)
                                            .background(Color.black.opacity(0.6)).clipShape(Circle()).foregroundColor(showGrid ? .yellow : .white)
                                    }
                                    .transition(.move(edge: .top).combined(with: .opacity))

                                    // Ghost Toggle
                                    Button(action: {
                                        if ghostImage != nil { ghostImage = nil }
                                        else { isGhostPickerPresented = true }
                                    }) {
                                        Image(systemName: ghostImage != nil ? "xmark.square" : "square.on.square.dashed")
                                            .font(.title2).padding(10)
                                            .background(Color.black.opacity(0.6)).clipShape(Circle()).foregroundColor(ghostImage != nil ? .yellow : .white)
                                    }
                                    .transition(.move(edge: .top).combined(with: .opacity))
                                }
                            }
                        }
                    }
                }
                .padding(.horizontal)
                .padding(.top, 60)
                
                Spacer()
                
                // BOTTOM BAR
                if let captured = cameraService.capturedImage {
                    // REVIEW MODE
                    HStack(alignment: .center, spacing: 50) {
                        Button(action: { cameraService.retake() }) {
                            Text("Retake")
                                .font(.headline)
                                .frame(width: 120, height: 50) // Fixed size for symmetry
                        }
                        .background(Color.black.opacity(0.6))
                        .foregroundColor(.white).cornerRadius(10)
                        
                        Button(action: {
                            PhotoLibraryManager.shared.saveWithMetadata(image: captured, metadata: currentMetadata)
                            cameraService.retake()
                        }) {
                            Text("Use Photo")
                                .font(.headline)
                                .frame(width: 120, height: 50) // Fixed size for symmetry
                        }
                        .background(Color.blue)
                        .foregroundColor(.white).cornerRadius(10)
                    }
                    .frame(maxWidth: .infinity, alignment: .center)
                    .padding(.bottom, 100)
                } else {
                    // CAPTURE MODE
                    ZStack {
                        if ghostImage != nil {
                            VStack {
                                Slider(value: $ghostOpacity, in: 0.1...0.8).accentColor(.blue).frame(width: 200)
                                Spacer().frame(height: 180) // Moved up to clear shutter
                            }
                        }
                        
                        // Shutter Button (Center)
                        Button(action: { 
                            withAnimation(.easeInOut(duration: 0.1)) { showShutterEffect = true }
                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                                withAnimation { showShutterEffect = false }
                            }
                            cameraService.takePhoto() 
                        }) {
                            ZStack {
                                Circle().stroke(Color.white, lineWidth: 4).frame(width: 72, height: 72)
                                Circle().fill(Color.white).frame(width: 62, height: 62)
                            }
                        }
                        .padding(.bottom, 100)
                        
                        // Flip Camera (Bottom Right)
                        HStack {
                            Spacer()
                            Button(action: { cameraService.flipCamera() }) {
                                Image(systemName: "arrow.triangle.2.circlepath.camera")
                                    .font(.title2)
                                    .padding(10)
                                    .background(Color.black.opacity(0.6))
                                    .clipShape(Circle())
                                    .foregroundColor(.white)
                            }
                            .padding(.trailing, 30)
                            .padding(.bottom, 60)
                        }
                    }
                }
            }
            .zIndex(2) // Ensure controls are above the captured image
            
            // SHUTTER EFFECT FLASH
            if showShutterEffect {
                Color.black.ignoresSafeArea().zIndex(20)
            }
        }
        .ignoresSafeArea()
        .sheet(isPresented: $isGhostPickerPresented) {
            CustomGhostPicker(selectedImage: $ghostImage)
        }
    }
}

// MARK: - CAMERA PREVIEW & INTERACTION
struct CameraPreview: UIViewRepresentable {
    var session: AVCaptureSession
    var onTap: (CGPoint) -> Void
    var onLongPress: (CGPoint) -> Void
    var onPan: (CGFloat) -> Void
    var onPinch: (CGFloat) -> Void
    @Binding var touchPoint: CGPoint?
    
    class VideoPreviewView: UIView {
        override class var layerClass: AnyClass { AVCaptureVideoPreviewLayer.self }
        var videoPreviewLayer: AVCaptureVideoPreviewLayer { return layer as! AVCaptureVideoPreviewLayer }
    }
    
    func makeUIView(context: Context) -> VideoPreviewView {
        let view = VideoPreviewView()
        view.backgroundColor = .black
        view.videoPreviewLayer.session = session
        view.videoPreviewLayer.videoGravity = .resizeAspectFill
        view.videoPreviewLayer.connection?.videoOrientation = .portrait
        
        // Tap Gesture
        let tap = UITapGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handleTap(_:)))
        view.addGestureRecognizer(tap)
        
        // Long Press Gesture
        let longPress = UILongPressGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handleLongPress(_:)))
        longPress.minimumPressDuration = 1.0 // Increased to 1.0s
        view.addGestureRecognizer(longPress)
        
        // Pan Gesture (Vertical drag for exposure)
        let pan = UIPanGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handlePan(_:)))
        view.addGestureRecognizer(pan)

        // Pinch Gesture (Zoom)
        let pinch = UIPinchGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handlePinch(_:)))
        view.addGestureRecognizer(pinch)

        return view
    }
    
    func updateUIView(_ uiView: VideoPreviewView, context: Context) {}
    
    func makeCoordinator() -> Coordinator { Coordinator(self) }
    
    class Coordinator: NSObject {
        var parent: CameraPreview

        init(_ parent: CameraPreview) { self.parent = parent }

        @objc func handleTap(_ gesture: UITapGestureRecognizer) {
            guard let view = gesture.view as? VideoPreviewView else { return }
            let location = gesture.location(in: view)
            parent.touchPoint = location
            let devicePoint = view.videoPreviewLayer.captureDevicePointConverted(fromLayerPoint: location)
            parent.onTap(devicePoint)
        }

        @objc func handleLongPress(_ gesture: UILongPressGestureRecognizer) {
            if gesture.state == .began {
                guard let view = gesture.view as? VideoPreviewView else { return }
                let location = gesture.location(in: view)
                parent.touchPoint = location
                let devicePoint = view.videoPreviewLayer.captureDevicePointConverted(fromLayerPoint: location)
                parent.onLongPress(devicePoint)
            }
        }

        @objc func handlePan(_ gesture: UIPanGestureRecognizer) {
            let translation = gesture.translation(in: gesture.view)
            // Vertical movement controls exposure
            parent.onPan(-translation.y)
            gesture.setTranslation(.zero, in: gesture.view)
        }

        @objc func handlePinch(_ gesture: UIPinchGestureRecognizer) {
            if gesture.state == .began || gesture.state == .changed {
                // Pass cumulative scale since gesture began (don't reset gesture.scale)
                parent.onPinch(gesture.scale)
            } else if gesture.state == .ended || gesture.state == .cancelled {
                parent.onPinch(0.0) // Signal end of pinch with 0.0
            }
        }
    }
}

struct CameraGridOverlay: View {
    var body: some View {
        GeometryReader { geometry in
            Path { path in
                let width = geometry.size.width
                let height = geometry.size.height
                path.move(to: CGPoint(x: width/3, y: 0)); path.addLine(to: CGPoint(x: width/3, y: height))
                path.move(to: CGPoint(x: 2*width/3, y: 0)); path.addLine(to: CGPoint(x: 2*width/3, y: height))
                path.move(to: CGPoint(x: 0, y: height/3)); path.addLine(to: CGPoint(x: width, y: height/3))
                path.move(to: CGPoint(x: 0, y: 2*height/3)); path.addLine(to: CGPoint(x: width, y: 2*height/3))
            }
            .stroke(Color.white.opacity(0.5), lineWidth: 1)
        }
        .aspectRatio(3/4, contentMode: .fit)
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

struct ZoomDialView: View {
    let currentZoom: CGFloat
    let minZoom: CGFloat
    let maxZoom: CGFloat

    // Fixed display range from 1x to 10x
    private let displayMin: CGFloat = 1.0
    private let displayMax: CGFloat = 10.0

    // Total width of the tick strip content
    private let stripContentWidth: CGFloat = 450
    // Visible width (2/3 of typical screen width ~250pt)
    private let visibleWidth: CGFloat = 250

    var normalizedZoom: CGFloat {
        // Normalize current zoom to 0-1 range based on display range (1-10)
        let clamped = min(max(currentZoom, displayMin), displayMax)
        return (clamped - displayMin) / (displayMax - displayMin)
    }

    var scrollOffset: CGFloat {
        // Calculate offset so indicator aligns with correct tick
        // At zoom 1.0 (normalizedZoom=0), tick 0 ("1" label) should be at center
        // At zoom 10.0 (normalizedZoom=1), tick 90 ("10" label) should be at center
        let tickSpacing: CGFloat = 5
        let firstTickCenter: CGFloat = tickSpacing / 2  // 2.5pt
        let lastTickCenter: CGFloat = 90 * tickSpacing + tickSpacing / 2  // 452.5pt
        let tickRange = lastTickCenter - firstTickCenter  // 450pt

        let targetTickPosition = firstTickCenter + normalizedZoom * tickRange
        return (visibleWidth / 2) - targetTickPosition
    }

    var body: some View {
        VStack(spacing: 4) {
            // Zoom value display
            Text(String(format: "%.1fx", currentZoom))
                .font(.system(size: 14, weight: .bold))
                .foregroundColor(.yellow)

            // Horizontal strip with tick marks
            ZStack {
                // Tick marks strip that scrolls - 90 ticks for 1-10 range (10 per integer)
                HStack(spacing: 0) {
                    ForEach(0..<91) { i in
                        // Each 10 ticks = 1 zoom level (0=1x, 10=2x, 20=3x, ... 90=10x)
                        let isMainTick = i % 10 == 0  // Integer zoom values
                        let isMidTick = i % 5 == 0 && !isMainTick  // Half-integer values
                        let tickHeight: CGFloat = isMainTick ? 16 : (isMidTick ? 10 : 6)
                        let tickWidth: CGFloat = isMainTick ? 2 : 1

                        VStack(spacing: 1) {
                            Rectangle()
                                .fill(Color.white)
                                .frame(width: tickWidth, height: tickHeight)

                            // Show zoom labels at integer values (1, 2, 3, ... 10)
                            if isMainTick {
                                let zoomValue = Int(displayMin) + (i / 10)
                                Text("\(zoomValue)")
                                    .font(.system(size: 8, weight: .medium))
                                    .foregroundColor(.white.opacity(0.8))
                            }
                        }
                        .frame(width: 5) // Spacing between ticks
                    }
                }
                .offset(x: scrollOffset)

                // Fade edges with gradient masks
                HStack {
                    LinearGradient(
                        gradient: Gradient(colors: [Color.black, Color.black.opacity(0)]),
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                    .frame(width: 40)

                    Spacer()

                    LinearGradient(
                        gradient: Gradient(colors: [Color.black.opacity(0), Color.black]),
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                    .frame(width: 40)
                }

                // Center indicator
                VStack(spacing: 0) {
                    Triangle()
                        .fill(Color.yellow)
                        .frame(width: 8, height: 6)
                    Rectangle()
                        .fill(Color.yellow)
                        .frame(width: 2, height: 18)
                }
            }
            .frame(width: visibleWidth, height: 38)
            .clipped()
        }
        .padding(.vertical, 6)
        .padding(.horizontal, 12)
        .background(Color.black.opacity(0.6))
        .cornerRadius(10)
    }
}

// Triangle shape for the indicator
struct Triangle: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        path.move(to: CGPoint(x: rect.midX, y: rect.maxY))
        path.addLine(to: CGPoint(x: rect.minX, y: rect.minY))
        path.addLine(to: CGPoint(x: rect.maxX, y: rect.minY))
        path.closeSubpath()
        return path
    }
}

// MARK: - PHOTO INFO PILL VIEW
enum PhotoInfoStage: Int, CaseIterable {
    case procedure = 0
    case tooth = 1
    case stage = 2
    case angle = 3
    case complete = 4

    var prompt: String {
        switch self {
        case .procedure: return "Choose procedure"
        case .tooth: return "Choose tooth"
        case .stage: return "Choose stage"
        case .angle: return "Choose angle"
        case .complete: return ""
        }
    }
}

struct PhotoInfoPillView: View {
    @Binding var metadata: PhotoMetadata
    @Binding var isDropdownOpen: Bool
    @ObservedObject var metadataManager = MetadataManager.shared

    @State private var currentStage: PhotoInfoStage = .procedure
    @State private var newProcedureText: String = ""
    @State private var selectedToothNumber: Int = 1
    @State private var selectedToothDate: Date = Date()
    @State private var showNewToothEntry: Bool = false

    var body: some View {
        VStack(spacing: 0) {
            // Main pill button
            Button(action: { withAnimation { isDropdownOpen.toggle() } }) {
                HStack(spacing: 6) {
                    // Show current selections with visual hierarchy
                    if metadata.procedure == nil {
                        Text("Choose procedure")
                            .font(.caption)
                            .foregroundColor(.white.opacity(0.7))
                    } else {
                        // Procedure badge
                        Text(metadata.procedure ?? "")
                            .font(.caption2).bold()
                            .padding(.horizontal, 6)
                            .padding(.vertical, 2)
                            .background(Color.blue.opacity(0.8))
                            .cornerRadius(4)

                        if let tooth = metadata.toothNumber {
                            Text("#\(tooth)")
                                .font(.caption2).bold()
                                .padding(.horizontal, 4)
                                .padding(.vertical, 2)
                                .background(Color.green.opacity(0.8))
                                .cornerRadius(4)
                        }

                        if let stage = metadata.stage {
                            Text(String(stage.prefix(4)))
                                .font(.caption2)
                                .padding(.horizontal, 4)
                                .padding(.vertical, 2)
                                .background(Color.orange.opacity(0.8))
                                .cornerRadius(4)
                        }

                        if let angle = metadata.angle {
                            Text(angle)
                                .font(.caption2)
                                .padding(.horizontal, 4)
                                .padding(.vertical, 2)
                                .background(Color.purple.opacity(0.8))
                                .cornerRadius(4)
                        }
                    }

                    Image(systemName: isDropdownOpen ? "chevron.up" : "chevron.down")
                        .font(.caption2)
                        .foregroundColor(.white.opacity(0.7))
                }
                .padding(.vertical, 8)
                .padding(.horizontal, 12)
                .background(Color.black.opacity(0.8))
                .cornerRadius(20)
                .overlay(
                    RoundedRectangle(cornerRadius: 20)
                        .stroke(isDropdownOpen ? Color.blue : Color.white.opacity(0.3), lineWidth: 1)
                )
            }
            .foregroundColor(.white)

            // Dropdown content
            if isDropdownOpen {
                dropdownContent
                    .padding(.top, 8)
                    .transition(.opacity.combined(with: .move(edge: .top)))
            }
        }
    }

    var dropdownContent: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Stage indicator
            HStack(spacing: 4) {
                ForEach(0..<4) { i in
                    Circle()
                        .fill(i <= currentStage.rawValue ? Color.blue : Color.gray.opacity(0.3))
                        .frame(width: 6, height: 6)
                }
                Spacer()
                Text(currentStage.prompt)
                    .font(.caption2)
                    .foregroundColor(.gray)
            }
            .padding(.horizontal, 12)
            .padding(.top, 8)

            Divider().background(Color.gray.opacity(0.3)).padding(.vertical, 8)

            // Stage-specific content
            ScrollView {
                VStack(alignment: .leading, spacing: 4) {
                    switch currentStage {
                    case .procedure:
                        procedureStageContent
                    case .tooth:
                        toothStageContent
                    case .stage:
                        stageStageContent
                    case .angle:
                        angleStageContent
                    case .complete:
                        EmptyView()
                    }
                }
                .padding(.horizontal, 8)
            }
            .frame(maxHeight: 200)

            // Back button (if not on first stage)
            if currentStage.rawValue > 0 {
                Divider().background(Color.gray.opacity(0.3))
                Button(action: { goToPreviousStage() }) {
                    HStack {
                        Image(systemName: "chevron.left")
                        Text("Back")
                    }
                    .font(.caption)
                    .foregroundColor(.blue)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                }
            }
        }
        .frame(width: 260)
        .background(Color.black.opacity(0.95))
        .cornerRadius(12)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(Color.gray.opacity(0.3), lineWidth: 1)
        )
        .onAppear { updateCurrentStage() }
    }

    // MARK: - Stage 1: Procedure Selection
    var procedureStageContent: some View {
        VStack(alignment: .leading, spacing: 4) {
            ForEach(metadataManager.procedures, id: \.self) { procedure in
                Button(action: {
                    metadata.procedure = procedure
                    advanceToNextStage()
                }) {
                    HStack {
                        Image(systemName: metadata.procedure == procedure ? "circle.inset.filled" : "circle")
                            .foregroundColor(.blue)
                        Text(procedure)
                            .foregroundColor(.white)
                        Spacer()
                    }
                    .padding(.vertical, 8)
                    .padding(.horizontal, 8)
                    .background(metadata.procedure == procedure ? Color.blue.opacity(0.2) : Color.clear)
                    .cornerRadius(6)
                }
            }

            // Add new procedure
            Divider().background(Color.gray.opacity(0.3)).padding(.vertical, 4)
            HStack(spacing: 8) {
                TextField("Add new...", text: $newProcedureText)
                    .font(.caption)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .foregroundColor(.black)

                Button(action: {
                    if !newProcedureText.isEmpty {
                        metadataManager.addProcedure(newProcedureText)
                        metadata.procedure = newProcedureText
                        newProcedureText = ""
                        advanceToNextStage()
                    }
                }) {
                    Image(systemName: "plus.circle.fill")
                        .foregroundColor(.green)
                }
                .disabled(newProcedureText.isEmpty)
            }
            .padding(.horizontal, 4)
        }
    }

    // MARK: - Stage 2: Tooth Selection
    var toothStageContent: some View {
        VStack(alignment: .leading, spacing: 8) {
            let existingTeeth = metadataManager.getToothEntries(for: metadata.procedure ?? "")

            if !existingTeeth.isEmpty && !showNewToothEntry {
                // Show previously entered teeth
                Text("Previous teeth:")
                    .font(.caption2)
                    .foregroundColor(.gray)
                    .padding(.horizontal, 4)

                ForEach(existingTeeth) { entry in
                    Button(action: {
                        metadata.toothNumber = entry.toothNumber
                        metadata.toothDate = entry.date
                        advanceToNextStage()
                    }) {
                        HStack {
                            Image(systemName: "tooth")
                                .foregroundColor(.green)
                            Text(entry.displayString)
                                .foregroundColor(.white)
                            Spacer()
                        }
                        .padding(.vertical, 8)
                        .padding(.horizontal, 8)
                        .background(Color.green.opacity(0.1))
                        .cornerRadius(6)
                    }
                }

                Divider().background(Color.gray.opacity(0.3)).padding(.vertical, 4)

                Button(action: { showNewToothEntry = true }) {
                    HStack {
                        Image(systemName: "plus.circle")
                            .foregroundColor(.blue)
                        Text("Enter new tooth")
                            .foregroundColor(.blue)
                    }
                    .padding(.vertical, 8)
                    .padding(.horizontal, 8)
                }
            } else {
                // New tooth entry form
                newToothEntryForm
            }
        }
    }

    var newToothEntryForm: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Tooth number picker
            VStack(alignment: .leading, spacing: 4) {
                Text("Tooth Number (1-32)")
                    .font(.caption2)
                    .foregroundColor(.gray)

                HStack {
                    Button(action: { if selectedToothNumber > 1 { selectedToothNumber -= 1 } }) {
                        Image(systemName: "minus.circle")
                            .foregroundColor(.white)
                    }

                    Text("\(selectedToothNumber)")
                        .font(.title3).bold()
                        .foregroundColor(.white)
                        .frame(width: 40)

                    Button(action: { if selectedToothNumber < 32 { selectedToothNumber += 1 } }) {
                        Image(systemName: "plus.circle")
                            .foregroundColor(.white)
                    }

                    Spacer()

                    // Quick select grid
                    LazyVGrid(columns: Array(repeating: GridItem(.fixed(20)), count: 8), spacing: 2) {
                        ForEach(1...32, id: \.self) { num in
                            Button(action: { selectedToothNumber = num }) {
                                Text("\(num)")
                                    .font(.system(size: 8))
                                    .foregroundColor(selectedToothNumber == num ? .black : .white)
                                    .frame(width: 18, height: 18)
                                    .background(selectedToothNumber == num ? Color.green : Color.gray.opacity(0.3))
                                    .cornerRadius(3)
                            }
                        }
                    }
                    .frame(width: 140)
                }
            }

            // Date picker
            VStack(alignment: .leading, spacing: 4) {
                Text("Date")
                    .font(.caption2)
                    .foregroundColor(.gray)

                DatePicker("", selection: $selectedToothDate, displayedComponents: .date)
                    .labelsHidden()
                    .colorScheme(.dark)
            }

            // Confirm button
            Button(action: {
                metadata.toothNumber = selectedToothNumber
                metadata.toothDate = selectedToothDate
                showNewToothEntry = false
                advanceToNextStage()
            }) {
                Text("Confirm Tooth #\(selectedToothNumber)")
                    .font(.caption).bold()
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 10)
                    .background(Color.green)
                    .cornerRadius(8)
            }

            if metadataManager.getToothEntries(for: metadata.procedure ?? "").count > 0 {
                Button(action: { showNewToothEntry = false }) {
                    Text("Cancel")
                        .font(.caption)
                        .foregroundColor(.gray)
                        .frame(maxWidth: .infinity)
                }
            }
        }
        .padding(.horizontal, 4)
    }

    // MARK: - Stage 3: Stage Selection (Preparation/Restoration)
    var stageStageContent: some View {
        VStack(alignment: .leading, spacing: 4) {
            ForEach(metadataManager.stages, id: \.self) { stage in
                Button(action: {
                    metadata.stage = stage
                    advanceToNextStage()
                }) {
                    HStack {
                        Image(systemName: stage == "Preparation" ? "wrench.and.screwdriver" : "checkmark.seal")
                            .foregroundColor(stage == "Preparation" ? .orange : .green)
                        Text(stage)
                            .foregroundColor(.white)
                        Spacer()
                        if metadata.stage == stage {
                            Image(systemName: "checkmark")
                                .foregroundColor(.blue)
                        }
                    }
                    .padding(.vertical, 10)
                    .padding(.horizontal, 8)
                    .background(metadata.stage == stage ? Color.blue.opacity(0.2) : Color.clear)
                    .cornerRadius(6)
                }
            }
        }
    }

    // MARK: - Stage 4: Angle Selection
    var angleStageContent: some View {
        VStack(alignment: .leading, spacing: 4) {
            ForEach(metadataManager.angles, id: \.self) { angle in
                Button(action: {
                    metadata.angle = angle
                    advanceToNextStage()
                }) {
                    HStack {
                        Image(systemName: angleIcon(for: angle))
                            .foregroundColor(.purple)
                        Text(angle)
                            .foregroundColor(.white)
                        Spacer()
                        if metadata.angle == angle {
                            Image(systemName: "checkmark")
                                .foregroundColor(.blue)
                        }
                    }
                    .padding(.vertical, 8)
                    .padding(.horizontal, 8)
                    .background(metadata.angle == angle ? Color.blue.opacity(0.2) : Color.clear)
                    .cornerRadius(6)
                }
            }
        }
    }

    func angleIcon(for angle: String) -> String {
        switch angle {
        case "Occlusal": return "arrow.down.circle"
        case "Buccal/Facial": return "arrow.left.circle"
        case "Lingual": return "arrow.right.circle"
        case "Proximal": return "arrow.left.arrow.right.circle"
        case "Mesial": return "arrow.up.left.circle"
        case "Distal": return "arrow.up.right.circle"
        default: return "questionmark.circle"
        }
    }

    // MARK: - Navigation
    func updateCurrentStage() {
        if metadata.procedure == nil {
            currentStage = .procedure
        } else if metadata.toothNumber == nil {
            currentStage = .tooth
        } else if metadata.stage == nil {
            currentStage = .stage
        } else if metadata.angle == nil {
            currentStage = .angle
        } else {
            currentStage = .complete
            isDropdownOpen = false
        }
    }

    func advanceToNextStage() {
        withAnimation {
            if let next = PhotoInfoStage(rawValue: currentStage.rawValue + 1) {
                currentStage = next
                if currentStage == .complete {
                    isDropdownOpen = false
                }
            }
        }
    }

    func goToPreviousStage() {
        withAnimation {
            if currentStage.rawValue > 0 {
                // Clear the current stage's data
                switch currentStage {
                case .tooth:
                    metadata.procedure = nil
                case .stage:
                    metadata.toothNumber = nil
                    metadata.toothDate = nil
                    showNewToothEntry = false
                case .angle:
                    metadata.stage = nil
                case .complete:
                    metadata.angle = nil
                default:
                    break
                }
                currentStage = PhotoInfoStage(rawValue: currentStage.rawValue - 1) ?? .procedure
            }
        }
    }
}

// MARK: - 3. GALLERY TAB & EDITOR
struct GalleryView: View {
    @StateObject private var library = PhotoLibraryManager.shared
    @ObservedObject var metadataManager = MetadataManager.shared
    @State private var isSidebarOpen = false
    @State private var selectedProcedure: String? = nil
    @State private var selectedTooth: ToothEntry? = nil
    @State private var expandedAngleStack: String? = nil

    let columns = [GridItem(.flexible()), GridItem(.flexible()), GridItem(.flexible())]

    // Get unique tooth entries for the selected procedure
    var toothEntriesForProcedure: [ToothEntry] {
        guard let proc = selectedProcedure else { return [] }
        return metadataManager.getToothEntries(for: proc)
    }

    // Get assets filtered by current selection
    var filteredAssets: [PHAsset] {
        var assets = library.assets
        if let proc = selectedProcedure {
            assets = assets.filter {
                metadataManager.getMetadata(for: $0.localIdentifier)?.procedure == proc
            }
        }
        if let tooth = selectedTooth {
            assets = assets.filter { asset in
                guard let meta = metadataManager.getMetadata(for: asset.localIdentifier) else { return false }
                return meta.toothNumber == tooth.toothNumber &&
                       meta.toothDate != nil && tooth.date != nil &&
                       Calendar.current.isDate(meta.toothDate!, inSameDayAs: tooth.date)
            }
        }
        return assets
    }

    // Group assets by stage (Preparation/Restoration)
    var assetsByStage: [String: [PHAsset]] {
        var grouped: [String: [PHAsset]] = ["Preparation": [], "Restoration": []]
        for asset in filteredAssets {
            if let stage = metadataManager.getMetadata(for: asset.localIdentifier)?.stage {
                grouped[stage, default: []].append(asset)
            } else {
                grouped["Preparation", default: []].append(asset)
            }
        }
        return grouped
    }

    // Group assets by angle within a stage, sorted by average rating
    func assetsByAngle(for stage: String) -> [(angle: String, assets: [PHAsset], avgRating: Double)] {
        let stageAssets = assetsByStage[stage] ?? []
        var grouped: [String: [PHAsset]] = [:]

        for asset in stageAssets {
            let angle = metadataManager.getMetadata(for: asset.localIdentifier)?.angle ?? "Other"
            grouped[angle, default: []].append(asset)
        }

        return grouped.map { (angle, assets) in
            let ratings = assets.compactMap { metadataManager.getRating(for: $0.localIdentifier) }
            let avg = ratings.isEmpty ? 0.0 : Double(ratings.reduce(0, +)) / Double(ratings.count)
            return (angle, assets, avg)
        }.sorted { $0.avgRating > $1.avgRating }
    }

    var body: some View {
        NavigationView {
            ZStack(alignment: .leading) {
                VStack(spacing: 0) {
                    // Header bar
                    HStack {
                        Button(action: { withAnimation { isSidebarOpen.toggle() } }) {
                            Image(systemName: "sidebar.left").font(.title2).foregroundColor(.blue)
                        }

                        // Breadcrumb navigation
                        if selectedProcedure != nil || selectedTooth != nil {
                            HStack(spacing: 4) {
                                if let proc = selectedProcedure {
                                    Button(action: { selectedTooth = nil }) {
                                        Text(proc)
                                            .font(.caption).bold()
                                            .foregroundColor(selectedTooth == nil ? .blue : .gray)
                                    }
                                }
                                if let tooth = selectedTooth {
                                    Image(systemName: "chevron.right")
                                        .font(.caption2)
                                        .foregroundColor(.gray)
                                    Text("Tooth \(tooth.toothNumber)")
                                        .font(.caption).bold()
                                        .foregroundColor(.blue)
                                }
                            }
                            .padding(.leading, 10)
                        }

                        Spacer()

                        // Photo count
                        Text("\(filteredAssets.count) photos")
                            .font(.caption)
                            .foregroundColor(.gray)
                    }
                    .padding()
                    .background(Color.black)
                    .zIndex(20)

                    // Main content
                    ScrollView {
                        if filteredAssets.isEmpty {
                            VStack(spacing: 20) {
                                Image(systemName: selectedTooth != nil ? "tooth" : "folder")
                                    .font(.system(size: 50))
                                    .foregroundColor(.gray)
                                Text(selectedTooth != nil ? "No photos for this tooth" : "Select a procedure")
                                    .foregroundColor(.gray)
                            }
                            .padding(.top, 100)
                        } else if selectedTooth != nil {
                            // Show grouped by stage and angle
                            VStack(alignment: .leading, spacing: 20) {
                                ForEach(["Preparation", "Restoration"], id: \.self) { stage in
                                    let angleGroups = assetsByAngle(for: stage)
                                    if !angleGroups.isEmpty {
                                        StageSection(
                                            stage: stage,
                                            angleGroups: angleGroups,
                                            expandedAngle: $expandedAngleStack,
                                            metadataManager: metadataManager
                                        )
                                    }
                                }
                            }
                            .padding()
                        } else {
                            // Show flat grid for procedure-level view
                            LazyVGrid(columns: columns, spacing: 15) {
                                ForEach(filteredAssets, id: \.localIdentifier) { asset in
                                    NavigationLink(destination: PhotoDetailView(asset: asset)) {
                                        AssetThumbnail(asset: asset)
                                            .frame(height: 120)
                                            .clipped()
                                    }
                                }
                            }
                            .padding()
                        }
                    }
                }
                .offset(x: isSidebarOpen ? 250 : 0)

                // Sidebar
                if isSidebarOpen {
                    HStack(spacing: 0) {
                        VStack(alignment: .leading, spacing: 0) {
                            Text("Procedures")
                                .font(.title3).bold()
                                .foregroundColor(.white)
                                .padding(.top, 50)
                                .padding(.horizontal)

                            // All Photos button
                            Button(action: {
                                selectedProcedure = nil
                                selectedTooth = nil
                                withAnimation { isSidebarOpen = false }
                            }) {
                                HStack {
                                    Image(systemName: "square.grid.2x2")
                                    Text("All Photos")
                                    Spacer()
                                }
                                .padding()
                                .foregroundColor(selectedProcedure == nil ? .blue : .white)
                                .background(selectedProcedure == nil ? Color.white.opacity(0.1) : Color.clear)
                            }

                            Divider().background(Color.gray)

                            // Procedure folders with tooth subfolders
                            ScrollView {
                                VStack(alignment: .leading, spacing: 0) {
                                    ForEach(metadataManager.procedures, id: \.self) { procedure in
                                        ProcedureFolderView(
                                            procedure: procedure,
                                            toothEntries: metadataManager.getToothEntries(for: procedure),
                                            selectedProcedure: $selectedProcedure,
                                            selectedTooth: $selectedTooth,
                                            isSidebarOpen: $isSidebarOpen,
                                            metadataManager: metadataManager,
                                            assets: library.assets
                                        )
                                    }
                                }
                            }

                            Spacer()
                        }
                        .frame(width: 250)
                        .background(Color(UIColor.systemGray6).opacity(0.98))
                        .edgesIgnoringSafeArea(.vertical)

                        // Tap outside to close
                        Color.clear
                            .contentShape(Rectangle())
                            .onTapGesture { withAnimation { isSidebarOpen = false } }
                    }
                    .zIndex(2)
                    .transition(.move(edge: .leading))
                }
            }
            .navigationBarHidden(true)
            .onAppear { library.fetchAssets() }
        }
    }
}

// MARK: - Procedure Folder View (with expandable tooth subfolders)
struct ProcedureFolderView: View {
    let procedure: String
    let toothEntries: [ToothEntry]
    @Binding var selectedProcedure: String?
    @Binding var selectedTooth: ToothEntry?
    @Binding var isSidebarOpen: Bool
    @ObservedObject var metadataManager: MetadataManager
    let assets: [PHAsset]
    @State private var isExpanded = false

    var photoCount: Int {
        assets.filter { metadataManager.getMetadata(for: $0.localIdentifier)?.procedure == procedure }.count
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Procedure row
            Button(action: {
                if toothEntries.isEmpty {
                    selectedProcedure = procedure
                    selectedTooth = nil
                    withAnimation { isSidebarOpen = false }
                } else {
                    withAnimation { isExpanded.toggle() }
                }
            }) {
                HStack {
                    Image(systemName: isExpanded ? "folder.fill" : "folder")
                        .foregroundColor(.blue)
                    Text(procedure)
                        .foregroundColor(selectedProcedure == procedure ? .blue : .white)
                    Spacer()
                    Text("\(photoCount)")
                        .font(.caption)
                        .foregroundColor(.gray)
                    if !toothEntries.isEmpty {
                        Image(systemName: isExpanded ? "chevron.down" : "chevron.right")
                            .font(.caption)
                            .foregroundColor(.gray)
                    }
                }
                .padding(.horizontal)
                .padding(.vertical, 10)
                .background(selectedProcedure == procedure && selectedTooth == nil ? Color.white.opacity(0.1) : Color.clear)
            }

            // Tooth subfolders (when expanded)
            if isExpanded {
                VStack(alignment: .leading, spacing: 0) {
                    // View all for this procedure
                    Button(action: {
                        selectedProcedure = procedure
                        selectedTooth = nil
                        withAnimation { isSidebarOpen = false }
                    }) {
                        HStack {
                            Image(systemName: "photo.on.rectangle.angled")
                                .foregroundColor(.gray)
                            Text("All \(procedure)")
                                .font(.caption)
                                .foregroundColor(selectedProcedure == procedure && selectedTooth == nil ? .blue : .white)
                            Spacer()
                        }
                        .padding(.leading, 40)
                        .padding(.vertical, 6)
                    }

                    ForEach(toothEntries) { entry in
                        ToothSubfolderRow(
                            entry: entry,
                            selectedTooth: $selectedTooth,
                            selectedProcedure: $selectedProcedure,
                            isSidebarOpen: $isSidebarOpen,
                            metadataManager: metadataManager,
                            assets: assets
                        )
                    }
                }
                .transition(.opacity)
            }
        }
    }
}

// MARK: - Tooth Subfolder Row
struct ToothSubfolderRow: View {
    let entry: ToothEntry
    @Binding var selectedTooth: ToothEntry?
    @Binding var selectedProcedure: String?
    @Binding var isSidebarOpen: Bool
    @ObservedObject var metadataManager: MetadataManager
    let assets: [PHAsset]

    var photoCount: Int {
        assets.filter { asset in
            guard let meta = metadataManager.getMetadata(for: asset.localIdentifier) else { return false }
            return meta.procedure == entry.procedure &&
                   meta.toothNumber == entry.toothNumber &&
                   meta.toothDate != nil &&
                   Calendar.current.isDate(meta.toothDate!, inSameDayAs: entry.date)
        }.count
    }

    var isSelected: Bool {
        guard let sel = selectedTooth else { return false }
        return sel.procedure == entry.procedure &&
               sel.toothNumber == entry.toothNumber &&
               Calendar.current.isDate(sel.date, inSameDayAs: entry.date)
    }

    var body: some View {
        Button(action: {
            selectedProcedure = entry.procedure
            selectedTooth = entry
            withAnimation { isSidebarOpen = false }
        }) {
            HStack {
                Image(systemName: "tooth")
                    .font(.caption)
                    .foregroundColor(.green)
                Text("#\(entry.toothNumber)")
                    .font(.caption).bold()
                    .foregroundColor(isSelected ? .blue : .white)
                Text(entry.dateString)
                    .font(.caption2)
                    .foregroundColor(.gray)
                Spacer()
                Text("\(photoCount)")
                    .font(.caption2)
                    .foregroundColor(.gray)
            }
            .padding(.leading, 40)
            .padding(.vertical, 6)
            .background(isSelected ? Color.white.opacity(0.1) : Color.clear)
        }
    }
}

// MARK: - Stage Section (Preparation/Restoration)
struct StageSection: View {
    let stage: String
    let angleGroups: [(angle: String, assets: [PHAsset], avgRating: Double)]
    @Binding var expandedAngle: String?
    @ObservedObject var metadataManager: MetadataManager

    let columns = [GridItem(.flexible()), GridItem(.flexible()), GridItem(.flexible())]

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Stage header
            HStack {
                Image(systemName: stage == "Preparation" ? "wrench.and.screwdriver" : "checkmark.seal")
                    .foregroundColor(stage == "Preparation" ? .orange : .green)
                Text(stage)
                    .font(.headline)
                    .foregroundColor(.white)
                Spacer()
                Text("\(angleGroups.flatMap { $0.assets }.count) photos")
                    .font(.caption)
                    .foregroundColor(.gray)
            }
            .padding(.vertical, 8)
            .padding(.horizontal, 12)
            .background(Color.gray.opacity(0.2))
            .cornerRadius(8)

            // Angle stacks
            LazyVGrid(columns: columns, spacing: 12) {
                ForEach(angleGroups, id: \.angle) { group in
                    AngleStackView(
                        angle: group.angle,
                        assets: group.assets,
                        avgRating: group.avgRating,
                        isExpanded: expandedAngle == "\(stage)-\(group.angle)",
                        onTap: {
                            withAnimation {
                                if expandedAngle == "\(stage)-\(group.angle)" {
                                    expandedAngle = nil
                                } else {
                                    expandedAngle = "\(stage)-\(group.angle)"
                                }
                            }
                        },
                        metadataManager: metadataManager
                    )
                }
            }
        }
    }
}

// MARK: - Angle Stack View (collated images by angle)
struct AngleStackView: View {
    let angle: String
    let assets: [PHAsset]
    let avgRating: Double
    let isExpanded: Bool
    let onTap: () -> Void
    @ObservedObject var metadataManager: MetadataManager

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            // Stack header
            Button(action: onTap) {
                VStack(alignment: .leading, spacing: 4) {
                    // Stacked preview (shows multiple overlapping thumbnails)
                    ZStack {
                        ForEach(Array(assets.prefix(3).enumerated().reversed()), id: \.element.localIdentifier) { index, asset in
                            AssetThumbnail(asset: asset)
                                .frame(height: 80)
                                .cornerRadius(6)
                                .shadow(radius: 2)
                                .offset(x: CGFloat(index) * 4, y: CGFloat(index) * 4)
                        }
                    }
                    .frame(height: 90)
                    .clipped()

                    HStack {
                        Text(angle)
                            .font(.caption2).bold()
                            .foregroundColor(.white)
                        Spacer()
                        Text("\(assets.count)")
                            .font(.caption2)
                            .foregroundColor(.gray)
                    }

                    // Rating stars
                    if avgRating > 0 {
                        HStack(spacing: 2) {
                            ForEach(1...5, id: \.self) { star in
                                Image(systemName: star <= Int(avgRating / 2) ? "star.fill" : "star")
                                    .font(.system(size: 8))
                                    .foregroundColor(.yellow)
                            }
                        }
                    }
                }
            }

            // Expanded view showing all images
            if isExpanded {
                VStack(spacing: 8) {
                    ForEach(assets, id: \.localIdentifier) { asset in
                        NavigationLink(destination: PhotoDetailView(asset: asset)) {
                            HStack {
                                AssetThumbnail(asset: asset)
                                    .frame(width: 60, height: 60)
                                    .cornerRadius(4)

                                VStack(alignment: .leading) {
                                    Text(angle)
                                        .font(.caption2)
                                        .foregroundColor(.white)
                                    RatingView(
                                        rating: metadataManager.getRating(for: asset.localIdentifier) ?? 0,
                                        assetID: asset.localIdentifier,
                                        metadataManager: metadataManager
                                    )
                                }
                                Spacer()
                            }
                            .padding(4)
                            .background(Color.gray.opacity(0.1))
                            .cornerRadius(6)
                        }
                    }
                }
                .padding(.top, 8)
                .transition(.opacity)
            }
        }
        .padding(8)
        .background(isExpanded ? Color.blue.opacity(0.1) : Color.gray.opacity(0.1))
        .cornerRadius(8)
    }
}

// MARK: - Rating View
struct RatingView: View {
    let rating: Int
    let assetID: String
    @ObservedObject var metadataManager: MetadataManager

    var body: some View {
        HStack(spacing: 2) {
            ForEach(1...10, id: \.self) { value in
                Button(action: {
                    metadataManager.setRating(value, for: assetID)
                }) {
                    Circle()
                        .fill(value <= rating ? Color.yellow : Color.gray.opacity(0.3))
                        .frame(width: 12, height: 12)
                }
            }
        }
    }
}

struct PhotoDetailView: View {
    let asset: PHAsset
    @State private var image: UIImage?
    @State private var isEditing = false
    @ObservedObject var metadataManager = MetadataManager.shared

    var metadata: PhotoMetadata? {
        metadataManager.getMetadata(for: asset.localIdentifier)
    }

    var body: some View {
        ZStack {
            Color.black.ignoresSafeArea()
            VStack {
                if let img = image {
                    Image(uiImage: img)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                } else {
                    ProgressView()
                }

                // Metadata display
                if let meta = metadata {
                    VStack(alignment: .leading, spacing: 8) {
                        // Top row: Procedure and Tooth
                        HStack(spacing: 8) {
                            if let proc = meta.procedure {
                                Text(proc)
                                    .font(.caption).bold()
                                    .padding(.horizontal, 8)
                                    .padding(.vertical, 4)
                                    .background(Color.blue.opacity(0.8))
                                    .cornerRadius(4)
                            }
                            if let tooth = meta.toothNumber {
                                HStack(spacing: 2) {
                                    Image(systemName: "tooth")
                                        .font(.caption2)
                                    Text("#\(tooth)")
                                        .font(.caption).bold()
                                }
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(Color.green.opacity(0.8))
                                .cornerRadius(4)
                            }
                            if let date = meta.toothDate {
                                let formatter = DateFormatter()
                                let _ = formatter.dateStyle = .short
                                Text(formatter.string(from: date))
                                    .font(.caption2)
                                    .foregroundColor(.gray)
                            }
                        }

                        // Second row: Stage and Angle
                        HStack(spacing: 8) {
                            if let stage = meta.stage {
                                HStack(spacing: 4) {
                                    Image(systemName: stage == "Preparation" ? "wrench.and.screwdriver" : "checkmark.seal")
                                        .font(.caption2)
                                    Text(stage)
                                        .font(.caption)
                                }
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(stage == "Preparation" ? Color.orange.opacity(0.8) : Color.green.opacity(0.8))
                                .cornerRadius(4)
                            }
                            if let angle = meta.angle {
                                Text(angle)
                                    .font(.caption)
                                    .padding(.horizontal, 8)
                                    .padding(.vertical, 4)
                                    .background(Color.purple.opacity(0.8))
                                    .cornerRadius(4)
                            }
                        }

                        // Rating row
                        HStack {
                            Text("Rating:")
                                .font(.caption)
                                .foregroundColor(.gray)
                            RatingView(
                                rating: meta.rating ?? 0,
                                assetID: asset.localIdentifier,
                                metadataManager: metadataManager
                            )
                        }
                    }
                    .padding()
                    .background(Color.black.opacity(0.7))
                    .cornerRadius(10)
                    .padding()
                }
            }
        }
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button("Edit") { isEditing = true }
            }
        }
        .fullScreenCover(isPresented: $isEditing) {
            if let img = image { PhotoEditorView(inputImage: img) }
        }
        .onAppear {
            PhotoLibraryManager.shared.requestImage(for: asset) { loadedImg in
                self.image = loadedImg
            }
        }
    }
}

// MARK: - 4. ADVANCED PHOTO EDITOR
struct PhotoEditorView: View {
    let inputImage: UIImage
    @State private var displayedImage: UIImage?
    @State private var baseImage: UIImage? 
    @Environment(\.presentationMode) var presentationMode
    @State private var selectedTab = 0
    @State private var brightness = 0.0
    @State private var contrast = 1.0
    @State private var saturation = 1.0
    @State private var sharpness = 0.0
    @State private var rotation = 0.0
    private let context = CIContext()
    
    var body: some View {
        NavigationView {
            VStack {
                Spacer()
                if let img = displayedImage { Image(uiImage: img).resizable().aspectRatio(contentMode: .fit).padding() }
                else { ProgressView() }
                Spacer()
                VStack(spacing: 20) {
                    if selectedTab == 0 {
                        HStack(spacing: 40) {
                            Button(action: { rotateImage() }) { VStack { Image(systemName: "rotate.right").font(.title2); Text("Rotate").font(.caption) } }
                            Button(action: { cropSquare() }) { VStack { Image(systemName: "crop").font(.title2); Text("Square").font(.caption) } }
                        }.foregroundColor(.white).padding()
                    } else {
                        VStack(spacing: 15) {
                            AdjustmentRow(icon: "sun.max", label: "Bright", value: $brightness, range: -2.0...2.0)
                            AdjustmentRow(icon: "circle.righthalf.filled", label: "Contrast", value: $contrast, range: 0.5...1.5)
                            AdjustmentRow(icon: "drop.fill", label: "Sat", value: $saturation, range: 0.0...2.0)
                            AdjustmentRow(icon: "triangle", label: "Sharp", value: $sharpness, range: 0.0...10.0)
                        }.padding(.horizontal)
                    }
                    Divider().background(Color.gray)
                    HStack {
                        Button(action: { selectedTab = 0 }) { VStack { Image(systemName: "crop.rotate"); Text("Transform").font(.caption2) } }
                        .frame(maxWidth: .infinity).foregroundColor(selectedTab == 0 ? .blue : .gray)
                        Button(action: { selectedTab = 1 }) { VStack { Image(systemName: "slider.horizontal.3"); Text("Adjust").font(.caption2) } }
                        .frame(maxWidth: .infinity).foregroundColor(selectedTab == 1 ? .blue : .gray)
                    }.padding(.top, 10)
                }.padding(.bottom).background(Color(UIColor.secondarySystemBackground))
            }
            .navigationTitle("Edit").navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) { Button("Cancel") { presentationMode.wrappedValue.dismiss() } }
                ToolbarItem(placement: .navigationBarTrailing) { Button("Save") { saveImage() } }
            }
            .onAppear { baseImage = inputImage; displayedImage = inputImage; applyProcessing() }
            .onChange(of: brightness) { _ in applyProcessing() }
            .onChange(of: contrast) { _ in applyProcessing() }
            .onChange(of: saturation) { _ in applyProcessing() }
            .onChange(of: sharpness) { _ in applyProcessing() }
        }
    }
    
    func applyProcessing() {
        guard let currentDisplay = baseImage else { return }
        let beginImage = CIImage(image: currentDisplay)
        let exposureFilter = CIFilter.exposureAdjust(); exposureFilter.inputImage = beginImage; exposureFilter.ev = Float(brightness)
        guard let exposureOutput = exposureFilter.outputImage else { return }
        let colorFilter = CIFilter.colorControls(); colorFilter.inputImage = exposureOutput; colorFilter.brightness = 0; colorFilter.contrast = Float(contrast); colorFilter.saturation = Float(saturation)
        guard let colorOutput = colorFilter.outputImage else { return }
        let sharpFilter = CIFilter.sharpenLuminance(); sharpFilter.inputImage = colorOutput; sharpFilter.sharpness = Float(sharpness)
        guard let finalOutput = sharpFilter.outputImage else { return }
        if let cgimg = context.createCGImage(finalOutput, from: finalOutput.extent) {
            let processed = UIImage(cgImage: cgimg, scale: currentDisplay.scale, orientation: currentDisplay.imageOrientation)
            displayedImage = processed
        }
    }
    
    func rotateImage() { guard let img = baseImage else { return }; baseImage = img.rotated(by: Measurement(value: -90, unit: .degrees)); applyProcessing() }
    func cropSquare() { guard let img = baseImage else { return }; baseImage = cropToSquare(image: img); applyProcessing() }
    func saveImage() { if let final = displayedImage { PhotoLibraryManager.shared.save(image: final, procedure: nil, otherTags: []) }; presentationMode.wrappedValue.dismiss() }
    func cropToSquare(image: UIImage) -> UIImage? {
        let sideLength = min(image.size.width, image.size.height)
        let xOffset = (image.size.width - sideLength) / 2.0; let yOffset = (image.size.height - sideLength) / 2.0
        let cropRect = CGRect(x: xOffset, y: yOffset, width: sideLength, height: sideLength)
        guard let cgImage = image.cgImage?.cropping(to: cropRect) else { return nil }
        return UIImage(cgImage: cgImage, scale: image.scale, orientation: image.imageOrientation)
    }
}

struct AdjustmentRow: View {
    let icon: String; let label: String; @Binding var value: Double; let range: ClosedRange<Double>
    var body: some View {
        HStack { Image(systemName: icon).frame(width: 25); Text(label).font(.caption).frame(width: 50, alignment: .leading); Slider(value: $value, in: range) }.foregroundColor(.primary)
    }
}

extension UIImage {
    func rotated(by angle: Measurement<UnitAngle>) -> UIImage? {
        let radians = CGFloat(angle.converted(to: .radians).value)
        var newSize = CGRect(origin: CGPoint.zero, size: self.size).applying(CGAffineTransform(rotationAngle: radians)).size
        newSize.width = floor(newSize.width); newSize.height = floor(newSize.height)
        UIGraphicsBeginImageContextWithOptions(newSize, false, self.scale)
        let context = UIGraphicsGetCurrentContext()!
        context.translateBy(x: newSize.width/2, y: newSize.height/2); context.rotate(by: radians)
        self.draw(in: CGRect(x: -self.size.width/2, y: -self.size.height/2, width: self.size.width, height: self.size.height))
        let newImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext(); return newImage
    }
}

// MARK: - 5. HELPERS
struct CustomGhostPicker: View {
    @Binding var selectedImage: UIImage?
    @Environment(\.presentationMode) var presentationMode
    @StateObject private var library = PhotoLibraryManager.shared
    let columns = [GridItem(.flexible()), GridItem(.flexible()), GridItem(.flexible())]
    var body: some View {
        NavigationView {
            ScrollView {
                LazyVGrid(columns: columns, spacing: 1) {
                    ForEach(library.assets, id: \.localIdentifier) { asset in
                        Button(action: { library.requestImage(for: asset) { image in self.selectedImage = image; presentationMode.wrappedValue.dismiss() } }) { AssetThumbnail(asset: asset).frame(height: 120).clipped() }
                    }
                }
            }.navigationTitle("Select Ghost Reference").toolbar { ToolbarItem(placement: .navigationBarLeading) { Button("Cancel") { presentationMode.wrappedValue.dismiss() } } }.onAppear { library.fetchAssets() }
        }
    }
}

struct AssetThumbnail: View {
    let asset: PHAsset
    @State private var image: UIImage?
    var body: some View {
        Group { if let image = image { Image(uiImage: image).resizable().aspectRatio(contentMode: .fill) } else { Rectangle().fill(Color.gray.opacity(0.2)) } }
        .onAppear { PhotoLibraryManager.shared.requestThumbnail(for: asset) { img in self.image = img } }
    }
}

class PhotoLibraryManager: ObservableObject {
    static let shared = PhotoLibraryManager()
    @Published var assets: [PHAsset] = []
    private let albumName = "Dental Portfolio"
    
    func createAlbumIfNeeded() {
        let fetchOptions = PHFetchOptions(); fetchOptions.predicate = NSPredicate(format: "title = %@", albumName)
        let collection = PHAssetCollection.fetchAssetCollections(with: .album, subtype: .any, options: fetchOptions)
        if collection.firstObject == nil {
            PHPhotoLibrary.shared().performChanges({ PHAssetCollectionChangeRequest.creationRequestForAssetCollection(withTitle: self.albumName) }, completionHandler: nil)
        }
    }
    
    func save(image: UIImage, procedure: String?, otherTags: [String]) {
        createAlbumIfNeeded()
        var placeholder: PHObjectPlaceholder?
        PHPhotoLibrary.shared().performChanges({
            let assetRequest = PHAssetCreationRequest.creationRequestForAsset(from: image)
            placeholder = assetRequest.placeholderForCreatedAsset
            let fetchOptions = PHFetchOptions(); fetchOptions.predicate = NSPredicate(format: "title = %@", self.albumName)
            let collection = PHAssetCollection.fetchAssetCollections(with: .album, subtype: .any, options: fetchOptions)
            guard let album = collection.firstObject, let albumChangeRequest = PHAssetCollectionChangeRequest(for: album), let assetPlaceholder = placeholder else { return }
            albumChangeRequest.addAssets([assetPlaceholder] as NSArray)
        }) { success, error in
            if success, let id = placeholder?.localIdentifier {
                DispatchQueue.main.async { TagManager.shared.assign(procedure: procedure, otherTags: otherTags, to: id); self.fetchAssets() }
            }
        }
    }

    func saveWithMetadata(image: UIImage, metadata: PhotoMetadata) {
        createAlbumIfNeeded()
        var placeholder: PHObjectPlaceholder?
        PHPhotoLibrary.shared().performChanges({
            let assetRequest = PHAssetCreationRequest.creationRequestForAsset(from: image)
            placeholder = assetRequest.placeholderForCreatedAsset
            let fetchOptions = PHFetchOptions(); fetchOptions.predicate = NSPredicate(format: "title = %@", self.albumName)
            let collection = PHAssetCollection.fetchAssetCollections(with: .album, subtype: .any, options: fetchOptions)
            guard let album = collection.firstObject, let albumChangeRequest = PHAssetCollectionChangeRequest(for: album), let assetPlaceholder = placeholder else { return }
            albumChangeRequest.addAssets([assetPlaceholder] as NSArray)
        }) { success, error in
            if success, let id = placeholder?.localIdentifier {
                DispatchQueue.main.async {
                    MetadataManager.shared.assignMetadata(metadata, to: id)
                    self.fetchAssets()
                }
            }
        }
    }
    
    func fetchAssets() {
        let fetchOptions = PHFetchOptions(); fetchOptions.predicate = NSPredicate(format: "title = %@", albumName)
        let collection = PHAssetCollection.fetchAssetCollections(with: .album, subtype: .any, options: fetchOptions)
        guard let album = collection.firstObject else { return }
        let assetsFetch = PHAsset.fetchAssets(in: album, options: nil)
        var newAssets: [PHAsset] = []; assetsFetch.enumerateObjects { asset, _, _ in newAssets.append(asset) }
        DispatchQueue.main.async { self.assets = newAssets.reversed() }
    }
    
    func requestThumbnail(for asset: PHAsset, completion: @escaping (UIImage?) -> Void) {
        let manager = PHImageManager.default()
        let options = PHImageRequestOptions(); options.isSynchronous = false; options.deliveryMode = .opportunistic
        manager.requestImage(for: asset, targetSize: CGSize(width: 200, height: 200), contentMode: .aspectFill, options: options) { img, _ in completion(img) }
    }
    
    func requestImage(for asset: PHAsset, completion: @escaping (UIImage?) -> Void) {
        let manager = PHImageManager.default()
        let options = PHImageRequestOptions(); options.isSynchronous = false; options.deliveryMode = .highQualityFormat
        manager.requestImage(for: asset, targetSize: PHImageManagerMaximumSize, contentMode: .aspectFit, options: options) { img, _ in completion(img) }
    }
}
